!    -*- f90 -*-
! Note: the context of this file is case sensitive.

python module _SHTOOLS ! in 
    interface  ! in 
        subroutine PlmBar(p,lmax,z,csphase,cnorm,p_d0) ! in PythonWrapper.f95
            fortranname pyplmbar
            use shtools, only: PlmBar
            real*8 dimension(p_d0),intent(out),depend(p_d0) :: p
            integer intent(in) :: lmax
            real*8 intent(in) :: z
            integer, optional,intent(in) :: csphase = 1
            integer, optional,intent(in) :: cnorm   = 0
            integer, intent(hide),depend(lmax) :: p_d0 = (lmax+1)*(lmax+2)/2
        end subroutine PlmBar

        subroutine PlmBar_d1(p,dp,lmax,z,csphase,cnorm,p_d0,dp_d0) ! in PythonWrapper.f95
            fortranname pyplmbar_d1
            use shtools, only: PlmBar_d1
            real*8, dimension(p_d0),intent(out),depend(p_d0) :: p
            real*8, dimension(dp_d0),intent(out),depend(dp_d0) :: dp
            integer, intent(in) :: lmax
            real*8, intent(in) :: z
            integer, optional,intent(in) :: csphase = 1
            integer, optional,intent(in) :: cnorm = 0
            integer, intent(hide),depend(lmax) :: p_d0 = (lmax+1)*(lmax+2)/2
            integer, intent(hide),depend(lmax) :: dp_d0 = (lmax+1)*(lmax+2)/2
        end subroutine PlmBar_d1

        subroutine PlBar(p,lmax,z,p_d0) ! in PythonWrapper.f95
            fortranname pyplbar
            use shtools, only: PlBar
            real*8, dimension(p_d0),intent(out),depend(p_d0) :: p
            integer, intent(in) :: lmax
            real*8, intent(in) :: z
            integer, intent(hide),depend(lmax) :: p_d0 = lmax+1
        end subroutine PlBar

        subroutine PlBar_d1(p,dp,lmax,z,p_d0,dp_d0) ! in PythonWrapper.f95
            fortranname pyplbar_d1
            use shtools, only: PlBar_d1
            real*8 dimension(p_d0),intent(out),depend(p_d0) :: p
            real*8 dimension(dp_d0),intent(out),depend(dp_d0) :: dp
            integer intent(in) :: lmax
            real*8 intent(in) :: z
            integer intent(hide),depend(lmax) :: p_d0=lmax+1
            integer intent(hide),depend(lmax) :: dp_d0=lmax+1
        end subroutine PlBar_d1

        subroutine PlmSchmidt(p,lmax,z,csphase,cnorm,p_d0) ! in PythonWrapper.f95
            fortranname pyplmschmidt
            use shtools, only: PlmSchmidt
            real*8 dimension(p_d0),intent(out),depend(p_d0) :: p
            integer intent(in) :: lmax
            real*8 intent(in) :: z
            integer, optional,intent(in) :: csphase = 1
            integer, optional,intent(in) :: cnorm = 0
            integer intent(hide),depend(lmax) :: p_d0 = (lmax+1)*(lmax+2)/2
        end subroutine PlmSchmidt

        subroutine PlSchmidt(p,lmax,z,p_d0) ! in PythonWrapper.f95
            fortranname pyplschmidt
            use shtools, only: PlSchmidt
            real*8 dimension(p_d0),intent(out),depend(p_d0) :: p
            integer intent(in) :: lmax
            real*8 intent(in) :: z
            integer intent(hide),depend(lmax) :: p_d0 = lmax+1
        end subroutine PlSchmidt

        subroutine PlmSchmidt_d1(p,dp,lmax,z,csphase,cnorm,p_d0,dp_d0) ! in PythonWrapper.f95
            fortranname pyplmschmidt_d1
            use shtools, only: PlmSchmidt_d1
            real*8 dimension(p_d0),intent(out),depend(p_d0) :: p
            real*8 dimension(dp_d0),intent(out),depend(dp_d0) :: dp
            integer intent(in) :: lmax
            real*8 intent(in) :: z
            integer, optional,intent(in) :: csphase = 1
            integer, optional,intent(in) :: cnorm = 0
            integer intent(hide),depend(lmax) :: p_d0 = (lmax+1)*(lmax+2)/2
            integer intent(hide),depend(lmax) :: dp_d0 = (lmax+1)*(lmax+2)/2
        end subroutine PlmSchmidt_d1

        subroutine PlSchmidt_d1(p,dp,lmax,z,p_d0,dp_d0) ! in PythonWrapper.f95
            fortranname pyplschmidt_d1
            use shtools, only: PlSchmidt_d1
            real*8 dimension(p_d0),intent(out),depend(p_d0) :: p
            real*8 dimension(dp_d0),intent(out),depend(dp_d0) :: dp
            integer intent(in) :: lmax
            real*8 intent(in) :: z
            integer intent(hide),depend(lmax) :: p_d0 = lmax+1
            integer intent(hide),depend(lmax) :: dp_d0 = lmax+1
        end subroutine PlSchmidt_d1

        subroutine PLegendre(p,lmax,z,p_d0) ! in PythonWrapper.f95
            fortranname pyplegendre
            use shtools, only: PLegendre
            real*8 dimension(p_d0),intent(out),depend(p_d0) :: p
            integer intent(in) :: lmax
            real*8 intent(in) :: z
            integer intent(in),depend(lmax) :: p_d0 = lmax+1
        end subroutine PLegendre

        subroutine PLegendreA(p,lmax,z,csphase,p_d0) ! in PythonWrapper.f95
            fortranname pyplegendrea
            use shtools, only: PLegendreA
            real*8 dimension(p_d0),intent(out),depend(p_d0) :: p
            integer intent(in) :: lmax
            real*8 intent(in) :: z
            integer, optional,intent(in) :: csphase = 1
            integer intent(hide),depend(lmax) :: p_d0 = (lmax+1)*(lmax+2)/2
        end subroutine PLegendreA

        subroutine PLegendre_d1(p,dp,lmax,z,p_d0,dp_d0) ! in PythonWrapper.f95
            fortranname pyplegendre_d1
            use shtools, only: PLegendre_d1
            real*8 dimension(p_d0),intent(out),depend(p_d0) :: p
            real*8 dimension(dp_d0),intent(out),depend(dp_d0) :: dp
            integer intent(in) :: lmax
            real*8 intent(in) :: z
            integer intent(hide),depend(lmax) :: p_d0  = lmax+1
            integer intent(hide),depend(lmax) :: dp_d0 = lmax+1
        end subroutine PLegendre_d1

        subroutine PLegendreA_d1(p,dp,lmax,z,csphase,p_d0,dp_d0) ! in PythonWrapper.f95
            fortranname pyplegendrea_d1
            use shtools, only: PLegendreA_d1
            real*8 dimension(p_d0),intent(out),depend(p_d0) :: p
            real*8 dimension(dp_d0),intent(out),depend(dp_d0) :: dp
            integer intent(in) :: lmax
            real*8 intent(in) :: z
            integer, optional,intent(in) :: csphase = 1
            integer intent(hide),depend(lmax) :: p_d0 = (lmax+1)*(lmax+2)/2
            integer intent(hide),depend(lmax) :: dp_d0= (lmax+1)*(lmax+2)/2
        end subroutine PLegendreA_d1

        subroutine CilmPlus(cilm,gridin,lmax,nmax,mass,d,rho,gridtype,w,zero,plx,n,dref,gridin_d0,gridin_d1,cilm_d0,cilm_d1,cilm_d2,plx_d0,plx_d1,zero_d0,w_d0) ! in PythonWrapper.f95
            fortranname pycilmplus
            use shtools, only: CilmPlus
            real*8 dimension(cilm_d0,cilm_d1,cilm_d2),intent(out),depend(cilm_d0,cilm_d1,cilm_d2) :: cilm
            real*8 dimension(gridin_d0,gridin_d1),intent(in) :: gridin
            integer intent(in) :: lmax
            integer intent(in) :: nmax
            real*8 intent(in) :: mass
            real*8 intent(out) :: d
            real*8 intent(in) :: rho
            integer intent(in) :: gridtype
            real*8, optional,dimension(w_d0),intent(in) :: w
            real*8, optional,dimension(zero_d0),intent(in) :: zero
            real*8, optional,dimension(plx_d0,plx_d1),intent(in) :: plx
            integer, optional,intent(in) :: n
            real*8, optional,intent(in) :: dref
            integer, optional,intent(in),check(shape(gridin,0)==gridin_d0),depend(gridin) :: gridin_d0=shape(gridin,0)
            integer, optional,intent(in),check(shape(gridin,1)==gridin_d1),depend(gridin) :: gridin_d1=shape(gridin,1)
            integer intent(in) :: cilm_d0
            integer intent(in) :: cilm_d1
            integer intent(in) :: cilm_d2
            integer, optional,intent(in),check(shape(plx,0)==plx_d0),depend(plx) :: plx_d0=shape(plx,0)
            integer, optional,intent(in),check(shape(plx,1)==plx_d1),depend(plx) :: plx_d1=shape(plx,1)
            integer, optional,intent(in),check(len(zero)>=zero_d0),depend(zero) :: zero_d0=len(zero)
            integer, optional,intent(in),check(len(w)>=w_d0),depend(w) :: w_d0=len(w)
        end subroutine CilmPlus

        subroutine CilmPlusRhoH(cilm,gridin,lmax,nmax,mass,d,rho,gridtype,w,zero,plx,n,dref,gridin_d0,gridin_d1,cilm_d0,cilm_d1,cilm_d2,plx_d0,plx_d1,zero_d0,w_d0,rho_d0,rho_d1) ! in PythonWrapper.f95
            fortranname pycilmplusrhoh
            use shtools, only: CilmPlusRhoH
            real*8 dimension(cilm_d0,cilm_d1,cilm_d2),intent(out),depend(cilm_d0,cilm_d1,cilm_d2) :: cilm
            real*8 dimension(gridin_d0,gridin_d1),intent(in) :: gridin
            integer intent(in) :: lmax
            integer intent(in) :: nmax
            real*8 intent(in) :: mass
            real*8 intent(out) :: d
            real*8 dimension(rho_d0,rho_d1),intent(in) :: rho
            integer intent(in) :: gridtype
            real*8, optional,dimension(w_d0),intent(in) :: w
            real*8, optional,dimension(zero_d0),intent(in) :: zero
            real*8, optional,dimension(plx_d0,plx_d1),intent(in) :: plx
            integer, optional,intent(in) :: n
            real*8, optional,intent(in) :: dref
            integer, optional,intent(in),check(shape(gridin,0)==gridin_d0),depend(gridin) :: gridin_d0=shape(gridin,0)
            integer, optional,intent(in),check(shape(gridin,1)==gridin_d1),depend(gridin) :: gridin_d1=shape(gridin,1)
            integer intent(in) :: cilm_d0
            integer intent(in) :: cilm_d1
            integer intent(in) :: cilm_d2
            integer, optional,intent(in),check(shape(plx,0)==plx_d0),depend(plx) :: plx_d0=shape(plx,0)
            integer, optional,intent(in),check(shape(plx,1)==plx_d1),depend(plx) :: plx_d1=shape(plx,1)
            integer, optional,intent(in),check(len(zero)>=zero_d0),depend(zero) :: zero_d0=len(zero)
            integer, optional,intent(in),check(len(w)>=w_d0),depend(w) :: w_d0=len(w)
            integer, optional,intent(in),check(shape(rho,0)==rho_d0),depend(rho) :: rho_d0=shape(rho,0)
            integer, optional,intent(in),check(shape(rho,1)==rho_d1),depend(rho) :: rho_d1=shape(rho,1)
        end subroutine CilmPlusRhoH

        subroutine Hilm(cilm,ba,gridglq,lmax,nmax,mass,r0,rho,gridtype,w,plx,zero,filter_type,filter_deg,lmax_calc,ba_d0,ba_d1,ba_d2,gridglq_d0,gridglq_d1,cilm_d0,cilm_d1,cilm_d2,zero_d0,w_d0,plx_d0,plx_d1) ! in PythonWrapper.f95
            fortranname pyhilm
            use shtools, only: Hilm
            real*8 dimension(cilm_d0,cilm_d1,cilm_d2),intent(out),depend(cilm_d0,cilm_d1,cilm_d2) :: cilm
            real*8 dimension(ba_d0,ba_d1,ba_d2),intent(in) :: ba
            real*8 dimension(gridglq_d0,gridglq_d1),intent(in) :: gridglq
            integer intent(in) :: lmax
            integer intent(in) :: nmax
            real*8 intent(in) :: mass
            real*8 intent(in) :: r0
            real*8 intent(in) :: rho
            integer intent(in) :: gridtype
            real*8, optional,dimension(w_d0),intent(in) :: w
            real*8, optional,dimension(plx_d0,plx_d1),intent(in) :: plx
            real*8, optional,dimension(zero_d0),intent(in) :: zero
            integer, optional,intent(in) :: filter_type
            integer, optional,intent(in) :: filter_deg
            integer, optional,intent(in) :: lmax_calc
            integer, optional,intent(in),check(shape(ba,0)==ba_d0),depend(ba) :: ba_d0=shape(ba,0)
            integer, optional,intent(in),check(shape(ba,1)==ba_d1),depend(ba) :: ba_d1=shape(ba,1)
            integer, optional,intent(in),check(shape(ba,2)==ba_d2),depend(ba) :: ba_d2=shape(ba,2)
            integer, optional,intent(in),check(shape(gridglq,0)==gridglq_d0),depend(gridglq) :: gridglq_d0=shape(gridglq,0)
            integer, optional,intent(in),check(shape(gridglq,1)==gridglq_d1),depend(gridglq) :: gridglq_d1=shape(gridglq,1)
            integer intent(in) :: cilm_d0
            integer intent(in) :: cilm_d1
            integer intent(in) :: cilm_d2
            integer, optional,intent(in),check(len(zero)>=zero_d0),depend(zero) :: zero_d0=len(zero)
            integer, optional,intent(in),check(len(w)>=w_d0),depend(w) :: w_d0=len(w)
            integer, optional,intent(in),check(shape(plx,0)==plx_d0),depend(plx) :: plx_d0=shape(plx,0)
            integer, optional,intent(in),check(shape(plx,1)==plx_d1),depend(plx) :: plx_d1=shape(plx,1)
        end subroutine Hilm

        subroutine HilmRhoH(cilm,ba,gridglq,lmax,nmax,mass,r0,rho,gridtype,w,plx,zero,filter_type,filter_deg,lmax_calc,ba_d0,ba_d1,ba_d2,gridglq_d0,gridglq_d1,cilm_d0,cilm_d1,cilm_d2,zero_d0,w_d0,rho_d0,rho_d1,plx_d0,plx_d1) ! in PythonWrapper.f95
            fortranname pyhilmrhoh
            use shtools, only: HilmRhoH
            real*8 dimension(cilm_d0,cilm_d1,cilm_d2),intent(out),depend(cilm_d0,cilm_d1,cilm_d2) :: cilm
            real*8 dimension(ba_d0,ba_d1,ba_d2),intent(in) :: ba
            real*8 dimension(gridglq_d0,gridglq_d1),intent(in) :: gridglq
            integer intent(in) :: lmax
            integer intent(in) :: nmax
            real*8 intent(in) :: mass
            real*8 intent(in) :: r0
            real*8 dimension(rho_d0,rho_d1),intent(in) :: rho
            integer intent(in) :: gridtype
            real*8, optional,dimension(w_d0),intent(in) :: w
            real*8, optional,dimension(plx_d0,plx_d1),intent(in) :: plx
            real*8, optional,dimension(zero_d0),intent(in) :: zero
            integer, optional,intent(in) :: filter_type
            integer, optional,intent(in) :: filter_deg
            integer, optional,intent(in) :: lmax_calc
            integer, optional,intent(in),check(shape(ba,0)==ba_d0),depend(ba) :: ba_d0=shape(ba,0)
            integer, optional,intent(in),check(shape(ba,1)==ba_d1),depend(ba) :: ba_d1=shape(ba,1)
            integer, optional,intent(in),check(shape(ba,2)==ba_d2),depend(ba) :: ba_d2=shape(ba,2)
            integer, optional,intent(in),check(shape(gridglq,0)==gridglq_d0),depend(gridglq) :: gridglq_d0=shape(gridglq,0)
            integer, optional,intent(in),check(shape(gridglq,1)==gridglq_d1),depend(gridglq) :: gridglq_d1=shape(gridglq,1)
            integer intent(in) :: cilm_d0
            integer intent(in) :: cilm_d1
            integer intent(in) :: cilm_d2
            integer, optional,intent(in),check(len(zero)>=zero_d0),depend(zero) :: zero_d0=len(zero)
            integer, optional,intent(in),check(len(w)>=w_d0),depend(w) :: w_d0=len(w)
            integer, optional,intent(in),check(shape(rho,0)==rho_d0),depend(rho) :: rho_d0=shape(rho,0)
            integer, optional,intent(in),check(shape(rho,1)==rho_d1),depend(rho) :: rho_d1=shape(rho,1)
            integer, optional,intent(in),check(shape(plx,0)==plx_d0),depend(plx) :: plx_d0=shape(plx,0)
            integer, optional,intent(in),check(shape(plx,1)==plx_d1),depend(plx) :: plx_d1=shape(plx,1)
        end subroutine HilmRhoH

        subroutine MakeGrid2d(grid,cilm,lmax,interval,nlat,nlong,norm,csphase,f,a,north,south,east,west,dealloc,cilm_d0,cilm_d1,cilm_d2,grid_d0,grid_d1) ! in PythonWrapper.f95
            fortranname pymakegrid2d
            use shtools, only: MakeGrid2d
            real*8 dimension(grid_d0,grid_d1),intent(out),depend(grid_d0,grid_d1) :: grid
            real*8 dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            integer intent(in) :: lmax
            real*8 intent(in) :: interval
            integer intent(out) :: nlat
            integer intent(out) :: nlong
            integer, optional,intent(in) :: norm
            integer, optional,intent(in) :: csphase
            real*8, optional,intent(in) :: f
            real*8, optional,intent(in) :: a
            real*8, optional,intent(in) :: north
            real*8, optional,intent(in) :: south
            real*8, optional,intent(in) :: east
            real*8, optional,intent(in) :: west
            integer, optional,intent(in) :: dealloc
            integer, optional,intent(in),check(shape(cilm,0)==cilm_d0),depend(cilm) :: cilm_d0=shape(cilm,0)
            integer, optional,intent(in),check(shape(cilm,1)==cilm_d1),depend(cilm) :: cilm_d1=shape(cilm,1)
            integer, optional,intent(in),check(shape(cilm,2)==cilm_d2),depend(cilm) :: cilm_d2=shape(cilm,2)
            integer intent(in) :: grid_d0
            integer intent(in) :: grid_d1
        end subroutine MakeGrid2d

        subroutine GLQGridCoord(latglq,longlq,lmax,nlat,nlong,latglq_d0,longlq_d0) ! in PythonWrapper.f95
            fortranname pyglqgridcoord
            use shtools, only: GLQGridCoord
            real*8 dimension(latglq_d0),intent(out),depend(latglq_d0) :: latglq
            real*8 dimension(longlq_d0),intent(out),depend(longlq_d0) :: longlq
            integer intent(in) :: lmax
            integer intent(out) :: nlat
            integer intent(out) :: nlong
            integer, optional,intent(in),depend(lmax) :: latglq_d0 = lmax+1
            integer, optional,intent(in),depend(lmax) :: longlq_d0 = 2*lmax+1
        end subroutine GLQGridCoord

        subroutine MakeGridGLQ(gridglq,cilm,lmax,zero,norm,csphase,lmax_calc,gridglq_d0,gridglq_d1,cilm_d0,cilm_d1,cilm_d2,zero_d0) ! in PythonWrapper.f95
            fortranname pymakegridglq
            use shtools, only: MakeGridGLQ
            real*8 dimension(gridglq_d0,gridglq_d1),intent(out),depend(gridglq_d0,gridglq_d1) :: gridglq
            real*8 dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            integer, optional,intent(in),depend(cilm_d1) :: lmax=cilm_d1-1
            real*8, dimension(zero_d0),intent(in) :: zero
            integer, optional,intent(in) :: norm = 1
            integer, optional,intent(in) :: csphase = 1
            integer, optional,intent(in),depend(lmax) :: lmax_calc = lmax
            integer, optional,intent(in),depend(lmax) :: gridglq_d0 = lmax+1
            integer, optional,intent(in),depend(lmax) :: gridglq_d1 = 2*lmax+1
            integer, optional,intent(in),check(shape(cilm,0)==cilm_d0),depend(cilm) :: cilm_d0=shape(cilm,0)
            integer, optional,intent(in),check(shape(cilm,1)==cilm_d1),depend(cilm) :: cilm_d1=shape(cilm,1)
            integer, optional,intent(in),check(shape(cilm,2)==cilm_d2),depend(cilm) :: cilm_d2=shape(cilm,2)
            integer, optional,intent(in),check(len(zero)>=zero_d0),depend(zero) :: zero_d0=len(zero)
        end subroutine MakeGridGLQ

        subroutine SHExpandGLQ(cilm,lmax,gridglq,w,zero,norm,csphase,lmax_calc,cilm_d0,cilm_d1,cilm_d2,gridglq_d0,gridglq_d1,zero_d0,w_d0) ! in PythonWrapper.f95
            fortranname pyshexpandglq
            use shtools, only: SHExpandGLQ
            real*8 dimension(cilm_d0,cilm_d1,cilm_d2),intent(out),depend(cilm_d0,cilm_d1,cilm_d2) :: cilm
            integer, optional,intent(in),depend(gridglq_d0) :: lmax=gridglq_d0-1
            real*8 dimension(gridglq_d0,gridglq_d1),intent(in) :: gridglq
            real*8 dimension(w_d0),intent(in) :: w
            real*8, dimension(zero_d0),intent(in) :: zero
            integer, optional,intent(in) :: norm = 1 
            integer, optional,intent(in) :: csphase = 1
            integer, optional,intent(in),depend(lmax) :: lmax_calc = lmax
            integer, optional,intent(in) :: cilm_d0 = 2
            integer, optional,intent(in),depend(lmax) :: cilm_d1 = lmax+1
            integer, optional,intent(in),depend(lmax) :: cilm_d2 = lmax+1
            integer, optional,intent(in),check(shape(gridglq,0)==gridglq_d0),depend(gridglq) :: gridglq_d0=shape(gridglq,0)
            integer, optional,intent(in),check(shape(gridglq,1)==gridglq_d1),depend(gridglq) :: gridglq_d1=shape(gridglq,1)
            integer, optional,intent(in),check(len(zero)>=zero_d0),depend(zero) :: zero_d0=len(zero)
            integer, optional,intent(in),check(len(w)>=w_d0),depend(w) :: w_d0=len(w)
        end subroutine SHExpandGLQ

        subroutine PreCompute(lmax,zero,w,wisdom_file,norm,csphase,cnorm,zero_d0,w_d0) ! in PythonWrapper.f95
            fortranname pyprecompute
            use shtools, only: PreCompute
            integer intent(in) :: lmax
            real*8 dimension(zero_d0),intent(out),depend(zero_d0) :: zero
            real*8 dimension(w_d0),intent(out),depend(w_d0) :: w
            character*(*), optional,intent(in) :: wisdom_file = ''
            integer, optional,intent(in) :: norm = 1
            integer, optional,intent(in) :: csphase = 1
            integer, optional,intent(in) :: cnorm = 0 !default value is not in the documentation
            integer intent(in),depend(lmax) :: zero_d0 = lmax + 1
            integer intent(in),depend(lmax) :: w_d0 = lmax + 1
        end subroutine PreCompute

        subroutine PreGLQ(x1,x2,n,zero,w,zero_d0,w_d0) ! in PythonWrapper.f95
            fortranname pypreglq
            use shtools, only: PreGLQ
            real*8 intent(in) :: x1
            real*8 intent(in) :: x2
            integer intent(in) :: n
            real*8 dimension(zero_d0),intent(out),depend(zero_d0) :: zero
            real*8 dimension(w_d0),intent(out),depend(w_d0) :: w
            integer, optional,intent(in),depend(n) :: zero_d0 = n
            integer, optional,intent(in),depend(n) :: w_d0 = n
        end subroutine PreGLQ

        function NGLQ(degree) ! in PythonWrapper.f95
            fortranname pynglq
            use shtools, only: NGLQ
            integer intent(in),check(degree > 0) :: degree
            integer :: NGLQ
        end function NGLQ

        function NGLQSH(degree) ! in PythonWrapper.f95
            fortranname pynglqsh
            use shtools, only: NGLQSH
            integer intent(in),check(degree > 0) :: degree
            integer :: NGLQSH
        end function NGLQSH

        function NGLQSHN(degree,n) ! in PythonWrapper.f95
            fortranname pynglqshn
            use shtools, only: NGLQSHN
            integer intent(in),check(degree > 0) :: degree
            integer intent(in) :: n
            integer :: NGLQSHN
        end function NGLQSHN

        subroutine SHRead(filename,cilm,lmax,lmax_in,skip,cilm_d0,cilm_d1,cilm_d2) ! in PythonWrapper.f95
            fortranname pyshread
            use shtools, only: SHRead
            character*(*) intent(in) :: filename
            real*8 dimension(cilm_d0,cilm_d1,cilm_d2),intent(out),depend(cilm_d0,cilm_d1,cilm_d2) :: cilm
            integer intent(out) :: lmax
            integer intent(in)  :: lmax_in
            integer, optional,intent(in) :: skip = 0
            integer, optional,intent(in),depend(lmax) :: cilm_d0 = 2
            integer, optional,intent(in),depend(lmax) :: cilm_d1 = lmax_in+1
            integer, optional,intent(in),depend(lmax) :: cilm_d2 = lmax_in+1
        end subroutine SHRead

        subroutine MakeMagGridDH(cilm,lmax,r0,a,f,rad_grid,theta_grid,phi_grid,total_grid,n,sampling,lmax_calc,pot_grid,total_grid_d0,total_grid_d1,cilm_d0,cilm_d1,cilm_d2,rad_grid_d0,rad_grid_d1,theta_grid_d0,theta_grid_d1,phi_grid_d0,phi_grid_d1,pot_grid_d0,pot_grid_d1) ! in PythonWrapper.f95
            fortranname pymakemaggriddh
            use shtools, only: MakeMagGridDH
            real*8 dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            integer intent(in) :: lmax
            real*8 intent(in) :: r0
            real*8 intent(in) :: a
            real*8 intent(in) :: f
            real*8 dimension(rad_grid_d0,rad_grid_d1),intent(out),depend(rad_grid_d0,rad_grid_d1) :: rad_grid
            real*8 dimension(theta_grid_d0,theta_grid_d1),intent(out),depend(theta_grid_d0,theta_grid_d1) :: theta_grid
            real*8 dimension(phi_grid_d0,phi_grid_d1),intent(out),depend(phi_grid_d0,phi_grid_d1) :: phi_grid
            real*8 dimension(total_grid_d0,total_grid_d1),intent(out),depend(total_grid_d0,total_grid_d1) :: total_grid
            integer intent(out) :: n
            integer, optional,intent(in) :: sampling
            integer, optional,intent(in) :: lmax_calc
            real*8, optional,dimension(pot_grid_d0,pot_grid_d1),intent(out),depend(pot_grid_d0,pot_grid_d1) :: pot_grid
            integer intent(in) :: total_grid_d0
            integer intent(in) :: total_grid_d1
            integer, optional,intent(in),check(shape(cilm,0)==cilm_d0),depend(cilm) :: cilm_d0=shape(cilm,0)
            integer, optional,intent(in),check(shape(cilm,1)==cilm_d1),depend(cilm) :: cilm_d1=shape(cilm,1)
            integer, optional,intent(in),check(shape(cilm,2)==cilm_d2),depend(cilm) :: cilm_d2=shape(cilm,2)
            integer intent(in) :: rad_grid_d0
            integer intent(in) :: rad_grid_d1
            integer intent(in) :: theta_grid_d0
            integer intent(in) :: theta_grid_d1
            integer intent(in) :: phi_grid_d0
            integer intent(in) :: phi_grid_d1
            integer intent(in) :: pot_grid_d0
            integer intent(in) :: pot_grid_d1
        end subroutine MakeMagGridDH

        function SHPowerL(c,l,c_d0,c_d1,c_d2) ! in PythonWrapper.f95
            fortranname pyshpowerl
            use shtools, only: SHPowerL
            real*8 dimension(c_d0,c_d1,c_d2),intent(in) :: c
            integer intent(in) :: l
            integer, optional,intent(in),depend(c) :: c_d0=shape(c,0)
            integer, optional,intent(in),depend(c) :: c_d1=shape(c,1)
            integer, optional,intent(in),depend(c) :: c_d2=shape(c,2)
            real*8 :: SHPowerL
        end function SHPowerL

        function SHPowerDensityL(c,l,c_d0,c_d1,c_d2) ! in PythonWrapper.f95
            fortranname pyshpowerdensityl
            use shtools, only: SHPowerDensityL
            real*8 dimension(c_d0,c_d1,c_d2),intent(in) :: c
            integer intent(in) :: l
            integer, optional,intent(in),check(shape(c,0)==c_d0),depend(c) :: c_d0=shape(c,0)
            integer, optional,intent(in),check(shape(c,1)==c_d1),depend(c) :: c_d1=shape(c,1)
            integer, optional,intent(in),check(shape(c,2)==c_d2),depend(c) :: c_d2=shape(c,2)
            real*8 :: SHPowerDensityL
        end function SHPowerDensityL

        function SHCrossPowerL(c1,c2,l,c2_d0,c2_d1,c2_d2,c1_d0,c1_d1,c1_d2) ! in PythonWrapper.f95
            fortranname pyshcrosspowerl
            use shtools, only: SHCrossPowerL
            real*8 dimension(c1_d0,c1_d1,c1_d2),intent(in) :: c1
            real*8 dimension(c2_d0,c2_d1,c2_d2),intent(in) :: c2
            integer intent(in) :: l
            integer, optional,intent(in),check(shape(c2,0)==c2_d0),depend(c2) :: c2_d0=shape(c2,0)
            integer, optional,intent(in),check(shape(c2,1)==c2_d1),depend(c2) :: c2_d1=shape(c2,1)
            integer, optional,intent(in),check(shape(c2,2)==c2_d2),depend(c2) :: c2_d2=shape(c2,2)
            integer, optional,intent(in),check(shape(c1,0)==c1_d0),depend(c1) :: c1_d0=shape(c1,0)
            integer, optional,intent(in),check(shape(c1,1)==c1_d1),depend(c1) :: c1_d1=shape(c1,1)
            integer, optional,intent(in),check(shape(c1,2)==c1_d2),depend(c1) :: c1_d2=shape(c1,2)
            real*8 :: SHCrossPowerL
        end function SHCrossPowerL

        function SHCrossPowerDensityL(c1,c2,l,c2_d0,c2_d1,c2_d2,c1_d0,c1_d1,c1_d2) ! in PythonWrapper.f95
            fortranname pyshcrosspowerdensityl
            use shtools, only: SHCrossPowerDensityL
            real*8 dimension(c1_d0,c1_d1,c1_d2),intent(in) :: c1
            real*8 dimension(c2_d0,c2_d1,c2_d2),intent(in) :: c2
            integer intent(in) :: l
            integer, optional,intent(in),check(shape(c2,0)==c2_d0),depend(c2) :: c2_d0=shape(c2,0)
            integer, optional,intent(in),check(shape(c2,1)==c2_d1),depend(c2) :: c2_d1=shape(c2,1)
            integer, optional,intent(in),check(shape(c2,2)==c2_d2),depend(c2) :: c2_d2=shape(c2,2)
            integer, optional,intent(in),check(shape(c1,0)==c1_d0),depend(c1) :: c1_d0=shape(c1,0)
            integer, optional,intent(in),check(shape(c1,1)==c1_d1),depend(c1) :: c1_d1=shape(c1,1)
            integer, optional,intent(in),check(shape(c1,2)==c1_d2),depend(c1) :: c1_d2=shape(c1,2)
            real*8 :: SHCrossPowerDensityL
        end function SHCrossPowerDensityL

        subroutine SHPowerSpectrum(c,lmax,spectra,c_d0,c_d1,c_d2,spectra_d0) ! in PythonWrapper.f95
            fortranname pyshpowerspectrum
            use shtools, only: SHPowerSpectrum
            real*8 dimension(c_d0,c_d1,c_d2),intent(in) :: c
            integer, optional,intent(in),depend(c) :: lmax = shape(c,1)-1
            real*8 dimension(spectra_d0),intent(out),depend(spectra_d0) :: spectra
            integer, optional,intent(in),check(shape(c,0)==c_d0),depend(c) :: c_d0=shape(c,0)
            integer, optional,intent(in),check(shape(c,1)==c_d1),depend(c) :: c_d1=shape(c,1)
            integer, optional,intent(in),check(shape(c,2)==c_d2),depend(c) :: c_d2=shape(c,2)
            integer, optional,intent(in),depend(lmax) :: spectra_d0=lmax+1
        end subroutine SHPowerSpectrum

        subroutine SHPowerSpectrumDensity(c,lmax,spectra,c_d0,c_d1,c_d2,spectra_d0) ! in PythonWrapper.f95
            fortranname pyshpowerspectrumdensity
            use shtools, only: SHPowerSpectrumDensity
            real*8 dimension(c_d0,c_d1,c_d2),intent(in) :: c
            integer, optional,intent(in),depend(c) :: lmax = shape(c,1)-1
            real*8 dimension(spectra_d0),intent(out),depend(spectra_d0) :: spectra
            integer, optional,intent(in),check(shape(c,0)==c_d0),depend(c) :: c_d0=shape(c,0)
            integer, optional,intent(in),check(shape(c,1)==c_d1),depend(c) :: c_d1=shape(c,1)
            integer, optional,intent(in),check(shape(c,2)==c_d2),depend(c) :: c_d2=shape(c,2)
            integer, optional,intent(in),depend(lmax) :: spectra_d0=lmax+1
        end subroutine SHPowerSpectrumDensity

        subroutine SHCrossPowerSpectrum(c1,c2,lmax,cspectra,c2_d0,c2_d1,c2_d2,c1_d0,c1_d1,c1_d2,cspectra_d0) ! in PythonWrapper.f95
            fortranname pyshcrosspowerspectrum
            use shtools, only: SHCrossPowerSpectrum
            real*8 dimension(c1_d0,c1_d1,c1_d2),intent(in) :: c1
            real*8 dimension(c2_d0,c2_d1,c2_d2),intent(in) :: c2
            integer, optional, intent(in),depend(c1_d1,c2_d1) :: lmax = min(c1_d1,c2_d1)-1
            real*8 dimension(cspectra_d0),intent(out),depend(cspectra_d0) :: cspectra
            integer, optional,intent(in),check(shape(c2,0)==c2_d0),depend(c2) :: c2_d0=shape(c2,0)
            integer, optional,intent(in),check(shape(c2,1)==c2_d1),depend(c2) :: c2_d1=shape(c2,1)
            integer, optional,intent(in),check(shape(c2,2)==c2_d2),depend(c2) :: c2_d2=shape(c2,2)
            integer, optional,intent(in),check(shape(c1,0)==c1_d0),depend(c1) :: c1_d0=shape(c1,0)
            integer, optional,intent(in),check(shape(c1,1)==c1_d1),depend(c1) :: c1_d1=shape(c1,1)
            integer, optional,intent(in),check(shape(c1,2)==c1_d2),depend(c1) :: c1_d2=shape(c1,2)
            integer, optional,intent(in),depend(lmax) :: cspectra_d0 = lmax+1
        end subroutine SHCrossPowerSpectrum

        subroutine SHCrossPowerSpectrumDensity(c1,c2,lmax,cspectra,c2_d0,c2_d1,c2_d2,c1_d0,c1_d1,c1_d2,cspectra_d0) ! in PythonWrapper.f95
            fortranname pyshcrosspowerspectrumdensity
            use shtools, only: SHCrossPowerSpectrumDensity
            real*8 dimension(c1_d0,c1_d1,c1_d2),intent(in) :: c1
            real*8 dimension(c2_d0,c2_d1,c2_d2),intent(in) :: c2
            integer, optional, intent(in),depend(c1_d1,c2_d1) :: lmax = min(c1_d1,c2_d1)-1
            real*8 dimension(cspectra_d0),intent(out),depend(cspectra_d0) :: cspectra
            integer, optional,intent(in),check(shape(c2,0)==c2_d0),depend(c2) :: c2_d0=shape(c2,0)
            integer, optional,intent(in),check(shape(c2,1)==c2_d1),depend(c2) :: c2_d1=shape(c2,1)
            integer, optional,intent(in),check(shape(c2,2)==c2_d2),depend(c2) :: c2_d2=shape(c2,2)
            integer, optional,intent(in),check(shape(c1,0)==c1_d0),depend(c1) :: c1_d0=shape(c1,0)
            integer, optional,intent(in),check(shape(c1,1)==c1_d1),depend(c1) :: c1_d1=shape(c1,1)
            integer, optional,intent(in),check(shape(c1,2)==c1_d2),depend(c1) :: c1_d2=shape(c1,2)
            integer, optional,intent(in),depend(lmax) :: cspectra_d0 = lmax+1
        end subroutine SHCrossPowerSpectrumDensity

        subroutine djpi2(dj,lmax,dj_d0,dj_d1,dj_d2) ! in PythonWrapper.f95
            fortranname pydjpi2
            use shtools, only: djpi2
            real*8 dimension(dj_d0,dj_d1,dj_d2),intent(out),depend(dj_d0,dj_d1,dj_d2) :: dj
            integer intent(in) :: lmax
            integer, optional,intent(in),depend(lmax) :: dj_d0 = lmax+1
            integer, optional,intent(in),depend(lmax) :: dj_d1 = lmax+1
            integer, optional,intent(in),depend(lmax) :: dj_d2 = lmax+1
        end subroutine djpi2

        subroutine SHrtoc(rcilm,ccilm,degmax,convention,switchcs,rcilm_d0,rcilm_d1,rcilm_d2,ccilm_d0,ccilm_d1,ccilm_d2) ! in PythonWrapper.f95
            fortranname pyshrtoc
            use shtools, only: SHrtoc
            real*8 dimension(rcilm_d0,rcilm_d1,rcilm_d2),intent(in) :: rcilm
            real*8 dimension(ccilm_d0,ccilm_d1,ccilm_d2),intent(out),depend(ccilm_d0,ccilm_d1,ccilm_d2) :: ccilm
            integer, optional,intent(in),depend(rcilm_d1) :: degmax = rcilm_d1-1
            integer, optional,intent(in) :: convention = 2
            integer, optional,intent(in) :: switchcs = 1
            integer, optional,intent(in),check(shape(rcilm,0)==rcilm_d0),depend(rcilm) :: rcilm_d0=shape(rcilm,0)
            integer, optional,intent(in),check(shape(rcilm,1)==rcilm_d1),depend(rcilm) :: rcilm_d1=shape(rcilm,1)
            integer, optional,intent(in),check(shape(rcilm,2)==rcilm_d2),depend(rcilm) :: rcilm_d2=shape(rcilm,2)
            integer, optional,intent(in),depend(rcilm_d0) :: ccilm_d0 = rcilm_d0
            integer, optional,intent(in),depend(rcilm_d1) :: ccilm_d1 = rcilm_d1
            integer, optional,intent(in),depend(rcilm_d2) :: ccilm_d2 = rcilm_d2
        end subroutine SHrtoc

        subroutine SHctor(ccilm,rcilm,degmax,convention,switchcs,rcilm_d0,rcilm_d1,rcilm_d2,ccilm_d0,ccilm_d1,ccilm_d2) ! in PythonWrapper.f95
            fortranname pyshctor
            use shtools, only: SHctor
            real*8 dimension(ccilm_d0,ccilm_d1,ccilm_d2),intent(in) :: ccilm
            real*8 dimension(rcilm_d0,rcilm_d1,rcilm_d2),intent(out),depend(rcilm_d0,rcilm_d1,rcilm_d2) :: rcilm
            integer, optional,intent(in),depend(ccilm_d1) :: degmax = ccilm_d1-1
            integer, optional,intent(in) :: convention = 2
            integer, optional,intent(in) :: switchcs = 1
            integer, optional,intent(in),depend(ccilm_d0) :: rcilm_d0 = ccilm_d0
            integer, optional,intent(in),depend(ccilm_d1) :: rcilm_d1 = ccilm_d1
            integer, optional,intent(in),depend(ccilm_d2) :: rcilm_d2 = ccilm_d2
            integer, optional,intent(in),check(shape(ccilm,0)==ccilm_d0),depend(ccilm) :: ccilm_d0=shape(ccilm,0)
            integer, optional,intent(in),check(shape(ccilm,1)==ccilm_d1),depend(ccilm) :: ccilm_d1=shape(ccilm,1)
            integer, optional,intent(in),check(shape(ccilm,2)==ccilm_d2),depend(ccilm) :: ccilm_d2=shape(ccilm,2)
        end subroutine SHctor

        subroutine SHCilmToCindex(cilm,cindex,degmax,cindex_d0,cindex_d1,cilm_d0,cilm_d1,cilm_d2) ! in PythonWrapper.f95
            fortranname pyshcilmtocindex
            use shtools, only: SHCilmToCindex
            real*8 dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            real*8 dimension(cindex_d0,cindex_d1),intent(out),depend(cindex_d0,cindex_d1) :: cindex
            integer, optional,intent(in),depend(cilm_d1) :: degmax = cilm_d1-1
            integer, optional,intent(in) :: cindex_d0 = 2
            integer, optional,intent(in),depend(degmax) :: cindex_d1 = (degmax+1)*(degmax+2)/2
            integer, optional,intent(in),depend(cilm) :: cilm_d0=shape(cilm,0)
            integer, optional,intent(in),depend(cilm) :: cilm_d1=shape(cilm,1)
            integer, optional,intent(in),depend(cilm) :: cilm_d2=shape(cilm,2)
        end subroutine SHCilmToCindex

        subroutine SHCindexToCilm(cindex,cilm,degmax,cindex_d0,cindex_d1,cilm_d0,cilm_d1,cilm_d2) ! in PythonWrapper.f95
            fortranname pyshcindextocilm
            use shtools, only: SHCindexToCilm
            real*8 dimension(cindex_d0,cindex_d1),intent(in) :: cindex
            real*8 dimension(cilm_d0,cilm_d1,cilm_d2),intent(out),depend(cilm_d0,cilm_d1,cilm_d2) :: cilm
            integer, optional,intent(in) :: degmax = (-3+sqrt(1+8*cindex_d1))/2
            integer, optional,intent(in),check(shape(cindex,0)==cindex_d0),depend(cindex) :: cindex_d0=shape(cindex,0)
            integer, optional,intent(in),check(shape(cindex,1)==cindex_d1),depend(cindex) :: cindex_d1=shape(cindex,1)
            integer, optional,intent(in) :: cilm_d0 = 2
            integer, optional,intent(in),depend(degmax) :: cilm_d1 = degmax+1
            integer, optional,intent(in),depend(degmax) :: cilm_d2 = degmax+1
        end subroutine SHCindexToCilm

        subroutine SHRotateCoef(x,cof,rcof,dj,lmax,rcof_d0,rcof_d1,dj_d0,dj_d1,dj_d2,cof_d0,cof_d1) ! in PythonWrapper.f95
            fortranname pyshrotatecoef
            use shtools, only: SHRotateCoef
            real*8 dimension(3),intent(in) :: x
            real*8 dimension(cof_d0,cof_d1),intent(in) :: cof
            real*8 dimension(dj_d0,dj_d1,dj_d2),intent(in) :: dj
            real*8 dimension(rcof_d0,rcof_d1),intent(out),depend(rcof_d0,rcof_d1) :: rcof
            integer, optional,intent(in),depend(cof_d1) :: lmax = (-3+sqrt(1+8*cof_d1))/2
            integer, optional,intent(in),depend(lmax) :: rcof_d0 = 2
            integer, optional,intent(in),depend(lmax) :: rcof_d1 = (lmax+1)*(lmax+2)/2
            integer, optional,intent(in),check(shape(dj,0)==dj_d0),depend(dj) :: dj_d0=shape(dj,0)
            integer, optional,intent(in),check(shape(dj,1)==dj_d1),depend(dj) :: dj_d1=shape(dj,1)
            integer, optional,intent(in),check(shape(dj,2)==dj_d2),depend(dj) :: dj_d2=shape(dj,2)
            integer, optional,intent(in),check(shape(cof,0)==cof_d0),depend(cof) :: cof_d0=shape(cof,0)
            integer, optional,intent(in),check(shape(cof,1)==cof_d1),depend(cof) :: cof_d1=shape(cof,1)
        end subroutine SHRotateCoef

        subroutine SHRotateRealCoef(cilmrot,cilm,lmax,x,dj,x_d0,dj_d0,dj_d1,dj_d2,cilm_d0,cilm_d1,cilm_d2,cilmrot_d0,cilmrot_d1,cilmrot_d2) ! in PythonWrapper.f95
            fortranname pyshrotaterealcoef
            use shtools, only: SHRotateRealCoef
            real*8 dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            real*8 dimension(cilmrot_d0,cilmrot_d1,cilmrot_d2),intent(out),depend(cilmrot_d0,cilmrot_d1,cilmrot_d2) :: cilmrot
            integer, optional,intent(in),depend(cilm_d1) :: lmax = cilm_d1-1
            real*8 dimension(x_d0),intent(in) :: x
            real*8 dimension(dj_d0,dj_d1,dj_d2),intent(in) :: dj
            integer, optional,intent(in),check(len(x)>=x_d0),depend(x) :: x_d0=len(x)
            integer, optional,intent(in),check(shape(dj,0)==dj_d0),depend(dj) :: dj_d0=shape(dj,0)
            integer, optional,intent(in),check(shape(dj,1)==dj_d1),depend(dj) :: dj_d1=shape(dj,1)
            integer, optional,intent(in),check(shape(dj,2)==dj_d2),depend(dj) :: dj_d2=shape(dj,2)
            integer, optional,intent(in),check(shape(cilm,0)==cilm_d0),depend(cilm) :: cilm_d0=shape(cilm,0)
            integer, optional,intent(in),check(shape(cilm,1)==cilm_d1),depend(cilm) :: cilm_d1=shape(cilm,1)
            integer, optional,intent(in),check(shape(cilm,2)==cilm_d2),depend(cilm) :: cilm_d2=shape(cilm,2)
            integer, optional,intent(in),depend(lmax) :: cilmrot_d0 = 2
            integer, optional,intent(in),depend(lmax) :: cilmrot_d1 = lmax+1
            integer, optional,intent(in),depend(lmax) :: cilmrot_d2 = lmax+1
        end subroutine SHRotateRealCoef

        subroutine DHaj(n,aj,aj_d0) ! in PythonWrapper.f95
            fortranname pydhaj
            use shtools, only: DHaj
            integer intent(in) :: n
            real*8 dimension(aj_d0),intent(out),depend(aj_d0) :: aj
            integer, optional,intent(in),depend(n),check(n%2==0) :: aj_d0 = n
        end subroutine DHaj

        subroutine SHExpandDH(grid,n,cilm,lmax,norm,sampling,csphase,lmax_calc,cilm_d0,cilm_d1,cilm_d2,grid_d0,grid_d1) ! in PythonWrapper.f95
            fortranname pyshexpanddh
            use shtools, only: SHExpandDH
            real*8 dimension(grid_d0,grid_d1),intent(in) :: grid
            integer, optional,intent(in),depend(grid_d0) :: n=grid_d0
            real*8 dimension(cilm_d0,cilm_d1,cilm_d2),intent(out),depend(cilm_d0,cilm_d1,cilm_d2) :: cilm
            integer, intent(hide) :: lmax
            integer, optional,intent(in) :: norm=1
            integer, optional,intent(in) :: sampling=1
            integer, optional,intent(in) :: csphase=1
            integer, optional,intent(in),depend(n) :: lmax_calc=n/2-1
            integer, optional,intent(in) :: cilm_d0=2
            integer, optional,intent(in),depend(n) :: cilm_d1=n/2
            integer, optional,intent(in),depend(n) :: cilm_d2=n/2
            integer, optional,intent(in),check(shape(grid,0)==grid_d0),depend(grid) :: grid_d0=shape(grid,0)
            integer, optional,intent(in),check(shape(grid,1)==grid_d1),depend(grid) :: grid_d1=shape(grid,1)
        end subroutine SHExpandDH

        subroutine MakeGridDH(griddh,n,cilm,lmax,norm,sampling,csphase,lmax_calc,cilm_d0,cilm_d1,cilm_d2,griddh_d0,griddh_d1) ! in PythonWrapper.f95
            fortranname pymakegriddh
            use shtools, only: MakeGridDH
            real*8 dimension(griddh_d0,griddh_d1),intent(out),depend(griddh_d0,griddh_d1) :: griddh
            integer intent(hide) :: n
            real*8 dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            integer, optional,intent(in),depend(cilm_d1) :: lmax=cilm_d1-1
            integer, optional,intent(in) :: norm=1
            integer, optional,intent(in) :: sampling=1
            integer, optional,intent(in) :: csphase=1
            integer, optional,intent(in),depend(cilm_d1) :: lmax_calc=cilm_d1-1
            integer, optional,intent(in),depend(cilm) :: cilm_d0=shape(cilm,0)
            integer, optional,intent(in),depend(cilm) :: cilm_d1=shape(cilm,1)
            integer, optional,intent(in),depend(cilm) :: cilm_d2=shape(cilm,2)
            integer, optional,intent(in),depend(lmax) :: griddh_d0=2*(lmax+1)
            integer, optional,intent(in),depend(griddh_d0,sampling) :: griddh_d1=sampling*griddh_d0
        end subroutine MakeGridDH

        function MakeGridPoint(cilm,lmax,lat,longitude,norm,csphase,dealloc,cilm_d0,cilm_d1,cilm_d2) ! in PythonWrapper.f95
            fortranname pymakegridpoint
            use shtools, only: MakeGridPoint
            real*8 dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            integer intent(in) :: lmax
            real*8 intent(in) :: lat
            real*8 intent(in) :: longitude
            integer, optional,intent(in) :: norm
            integer, optional,intent(in) :: csphase
            integer, optional,intent(in) :: dealloc
            integer, optional,intent(in),check(shape(cilm,0)==cilm_d0),depend(cilm) :: cilm_d0=shape(cilm,0)
            integer, optional,intent(in),check(shape(cilm,1)==cilm_d1),depend(cilm) :: cilm_d1=shape(cilm,1)
            integer, optional,intent(in),check(shape(cilm,2)==cilm_d2),depend(cilm) :: cilm_d2=shape(cilm,2)
            real*8 :: MakeGridPoint
        end function MakeGridPoint

        function Wl(l,half,r,d) ! in PythonWrapper.f95
            fortranname pywl
            use shtools, only: Wl
            integer intent(in) :: l
            integer intent(in) :: half
            real*8 intent(in) :: r
            real*8 intent(in) :: d
            real*8 :: Wl
        end function Wl

        function WlCurv(l,half,r,d) ! in PythonWrapper.f95
            fortranname pywlcurv
            use shtools, only: WlCurv
            integer intent(in) :: l
            integer intent(in) :: half
            real*8 intent(in) :: r
            real*8 intent(in) :: d
            real*8 :: WlCurv
        end function WlCurv

        subroutine SHExpandLSQ(cilm,d,lat,lon,nmax,lmax,norm,chi2,csphase,d_d0,lon_d0,cilm_d0,cilm_d1,cilm_d2,lat_d0) ! in PythonWrapper.f95
            fortranname pyshexpandlsq
            use shtools, only: SHExpandLSQ
            real*8 dimension(cilm_d0,cilm_d1,cilm_d2),intent(out),depend(cilm_d0,cilm_d1,cilm_d2) :: cilm
            real*8 dimension(d_d0),intent(in) :: d
            real*8 dimension(lat_d0),intent(in) :: lat
            real*8 dimension(lon_d0),intent(in) :: lon
            integer intent(in) :: nmax
            integer intent(in) :: lmax
            integer, optional,intent(in) :: norm
            real*8, optional,intent(out) :: chi2
            integer, optional,intent(in) :: csphase
            integer, optional,intent(in),check(len(d)>=d_d0),depend(d) :: d_d0=len(d)
            integer, optional,intent(in),check(len(lon)>=lon_d0),depend(lon) :: lon_d0=len(lon)
            integer intent(in) :: cilm_d0
            integer intent(in) :: cilm_d1
            integer intent(in) :: cilm_d2
            integer, optional,intent(in),check(len(lat)>=lat_d0),depend(lat) :: lat_d0=len(lat)
        end subroutine SHExpandLSQ

        subroutine SHMultiply(shout,sh1,lmax1,sh2,lmax2,precomp,norm,csphase,sh1_d0,sh1_d1,sh1_d2,sh2_d0,sh2_d1,sh2_d2,shout_d0,shout_d1,shout_d2) ! in PythonWrapper.f95
            fortranname pyshmultiply
            use shtools, only: SHMultiply
            real*8 dimension(shout_d0,shout_d1,shout_d2),intent(out),depend(shout_d0,shout_d1,shout_d2) :: shout
            real*8 dimension(sh1_d0,sh1_d1,sh1_d2),intent(in) :: sh1
            integer intent(in) :: lmax1
            real*8 dimension(sh2_d0,sh2_d1,sh2_d2),intent(in) :: sh2
            integer intent(in) :: lmax2
            integer, optional,intent(in) :: precomp
            integer, optional,intent(in) :: norm
            integer, optional,intent(in) :: csphase
            integer, optional,intent(in),check(shape(sh1,0)==sh1_d0),depend(sh1) :: sh1_d0=shape(sh1,0)
            integer, optional,intent(in),check(shape(sh1,1)==sh1_d1),depend(sh1) :: sh1_d1=shape(sh1,1)
            integer, optional,intent(in),check(shape(sh1,2)==sh1_d2),depend(sh1) :: sh1_d2=shape(sh1,2)
            integer, optional,intent(in),check(shape(sh2,0)==sh2_d0),depend(sh2) :: sh2_d0=shape(sh2,0)
            integer, optional,intent(in),check(shape(sh2,1)==sh2_d1),depend(sh2) :: sh2_d1=shape(sh2,1)
            integer, optional,intent(in),check(shape(sh2,2)==sh2_d2),depend(sh2) :: sh2_d2=shape(sh2,2)
            integer intent(in) :: shout_d0
            integer intent(in) :: shout_d1
            integer intent(in) :: shout_d2
        end subroutine SHMultiply

        subroutine ComputeD0(D0,lmax,theta0,D0_d0,D0_d1) ! in PythonWrapper.f95
            fortranname pycomputed0
            use shtools, only: ComputeD0
            real*8 dimension(D0_d0,D0_d1),intent(out),depend(D0_d0,D0_d1) :: D0
            integer intent(in) :: lmax
            real*8 intent(in) :: theta0
            integer,optional,intent(in),depend(lmax) :: D0_d0 = lmax+1
            integer,optional,intent(in),depend(lmax) :: D0_d1 = lmax+1
        end subroutine ComputeD0

        subroutine ComputeDm(dllm,lmax,m,theta0,dllm_d0,dllm_d1) ! in PythonWrapper.f95
            fortranname pycomputedm
            use shtools, only: ComputeDm
            real*8 dimension(dllm_d0,dllm_d1),intent(out),depend(dllm_d0,dllm_d1) :: dllm
            integer intent(in) :: lmax
            integer intent(in) :: m
            real*8 intent(in) :: theta0
            integer, optional,intent(in),depend(lmax) :: dllm_d0 = lmax+1
            integer, optional,intent(in),depend(lmax) :: dllm_d1 = lmax+1
        end subroutine ComputeDm

        subroutine SphericalCapCoef(coef,theta,lmax,coef_d0) ! in PythonWrapper.f95
            fortranname pysphericalcapcoef
            use shtools, only: SphericalCapCoef
            real*8 dimension(coef_d0),intent(out),depend(coef_d0) :: coef
            real*8 intent(in) :: theta
            integer intent(in) :: lmax
            integer, optional,intent(in),depend(lmax) :: coef_d0 = lmax+1
        end subroutine SphericalCapCoef

        subroutine EigValVecSym(ain,n,eig,evec,ul,K,evec_d0,evec_d1,ain_d0,ain_d1,eig_d0) ! in PythonWrapper.f95
            fortranname pyeigvalvecsym
            use shtools, only: EigValVecSym
            real*8 dimension(ain_d0,ain_d1),intent(in) :: ain
            integer intent(in) :: n
            real*8 dimension(eig_d0),intent(out),depend(eig_d0) :: eig
            real*8 dimension(evec_d0,evec_d1),intent(out),depend(evec_d0,evec_d1) :: evec
            character, optional,intent(in) :: ul
            integer, optional,intent(in) :: K
            integer intent(in) :: evec_d0
            integer intent(in) :: evec_d1
            integer, optional,intent(in),check(shape(ain,0)==ain_d0),depend(ain) :: ain_d0=shape(ain,0)
            integer, optional,intent(in),check(shape(ain,1)==ain_d1),depend(ain) :: ain_d1=shape(ain,1)
            integer intent(in) :: eig_d0
        end subroutine EigValVecSym

        subroutine SHReturnTapersM(theta0,lmax,m,tapers,eigenvalues,shannon,tapers_d0,tapers_d1,eigenvalues_d0) ! in PythonWrapper.f95
            fortranname pyshreturntapersm
            use shtools, only: SHReturnTapersM
            real*8 intent(in) :: theta0
            integer intent(in) :: lmax
            integer intent(in) :: m
            real*8 dimension(tapers_d0,tapers_d1),intent(out),depend(tapers_d0,tapers_d1) :: tapers
            real*8 dimension(eigenvalues_d0),intent(out),depend(eigenvalues_d0) :: eigenvalues
            real*8 intent(out) :: shannon
            integer intent(in) :: tapers_d0 = lmax+1
            integer intent(in) :: tapers_d1 = lmax+1
            integer intent(in) :: eigenvalues_d0 = lmax+1
        end subroutine SHReturnTapersM

        subroutine EigValSym(ain,n,eval,ul,ain_d0,ain_d1,eval_d0) ! in PythonWrapper.f95
            fortranname pyeigvalsym
            use shtools, only: EigValSym
            real*8 dimension(ain_d0,ain_d1),intent(in) :: ain
            integer intent(in) :: n
            real*8 dimension(eval_d0),intent(out),depend(eval_d0) :: eval
            character, optional,intent(in) :: ul
            integer, optional,intent(in),check(shape(ain,0)==ain_d0),depend(ain) :: ain_d0=shape(ain,0)
            integer, optional,intent(in),check(shape(ain,1)==ain_d1),depend(ain) :: ain_d1=shape(ain,1)
            integer intent(in) :: eval_d0
        end subroutine EigValSym

        function SHFindLWin(theta0,m,alpha,taper_number) ! in PythonWrapper.f95
            fortranname pyshfindlwin
            use shtools, only: SHFindLWin
            real*8 intent(in) :: theta0
            integer intent(in) :: m
            real*8 intent(in) :: alpha
            integer, optional,intent(in) :: taper_number = 1
            integer :: SHFindLWin
        end function SHFindLWin

        subroutine SHAdmitCorr(G,T,lmax,admit,corr,admit_error,G_d0,G_d1,G_d2,admit_d0,admit_error_d0,T_d0,T_d1,T_d2,corr_d0) ! in PythonWrapper.f95
            fortranname pyshadmitcorr
            use shtools, only: SHAdmitCorr
            real*8 dimension(G_d0,G_d1,G_d2),intent(in) :: G
            real*8 dimension(T_d0,T_d1,T_d2),intent(in) :: T
            integer, optional, intent(in),depend(G_d1,T_d1) :: lmax = min(G_d1,T_d1)-1
            real*8 dimension(admit_d0),intent(out),depend(admit_d0) :: admit
            real*8 dimension(corr_d0),intent(out),depend(corr_d0) :: corr
            real*8, optional,dimension(admit_error_d0),intent(out),depend(admit_error_d0) :: admit_error
            integer, optional,intent(in),check(shape(G,0)==G_d0),depend(G) :: G_d0=shape(G,0)
            integer, optional,intent(in),check(shape(G,1)==G_d1),depend(G) :: G_d1=shape(G,1)
            integer, optional,intent(in),check(shape(G,2)==G_d2),depend(G) :: G_d2=shape(G,2)
            integer, optional,intent(in),check(shape(T,0)==T_d0),depend(T) :: T_d0=shape(T,0)
            integer, optional,intent(in),check(shape(T,1)==T_d1),depend(T) :: T_d1=shape(T,1)
            integer, optional,intent(in),check(shape(T,2)==T_d2),depend(T) :: T_d2=shape(T,2)
            integer, optional,intent(in),depend(lmax) :: admit_d0 = lmax+1
            integer, optional,intent(in),depend(lmax) :: admit_error_d0 = lmax+1
            integer, optional,intent(in),depend(lmax) :: corr_d0 = lmax+1
        end subroutine SHAdmitCorr

        subroutine SHLocalizedAdmitCorr(tapers,taper_order,lwin,lat,lon,g,t,lmax,admit,corr,K,admit_error,corr_error,taper_wt,mtdef,k1linsig,taper_order_d0,g_d0,g_d1,g_d2,taper_wt_d0,corr_error_d0,admit_d0,admit_error_d0,corr_d0,tapers_d0,tapers_d1,t_d0,t_d1,t_d2) ! in PythonWrapper.f95
            fortranname pyshlocalizedadmitcorr
            use shtools, only: SHLocalizedAdmitCorr
            real*8 dimension(tapers_d0,tapers_d1),intent(in) :: tapers
            integer dimension(taper_order_d0),intent(in) :: taper_order
            integer,optional,intent(in),depend(tapers_d0) :: lwin = tapers_d0-1
            real*8 dimension(g_d0,g_d1,g_d2),intent(in) :: g
            real*8 dimension(t_d0,t_d1,t_d2),intent(in) :: t
            integer, optional,intent(in),depend(t_d1) :: lmax = t_d1-1
            real*8 dimension(admit_d0),intent(out),depend(admit_d0) :: admit
            real*8 dimension(corr_d0),intent(out),depend(corr_d0) :: corr
            integer, optional,intent(in),depend(tapers_d1) :: K = tapers_d1
            real*8, optional,dimension(admit_error_d0),intent(out),depend(admit_error_d0) :: admit_error
            real*8, optional,dimension(corr_error_d0),intent(out),depend(corr_error_d0) :: corr_error
            real*8, optional,dimension(taper_wt_d0),intent(in) :: taper_wt = -1
            real*8, optional,intent(in) :: lat = 0.0
            real*8, optional,intent(in) :: lon = 0.0
            integer, optional,intent(in) :: mtdef = 1
            integer, optional,intent(in) :: k1linsig = -1
            integer, optional,intent(in),check(tapers_d0>0),depend(tapers) :: tapers_d0=shape(tapers,0)
            integer, optional,intent(in),check(tapers_d1>0),depend(tapers) :: tapers_d1=shape(tapers,1)
            integer, optional,intent(in),check(taper_order_d0>0),depend(taper_order) :: taper_order_d0=len(taper_order)
            integer, optional,intent(in),check(taper_wt_d0>0),depend(tapers_d1) :: taper_wt_d0=tapers_d1
            integer, optional,intent(in),check(g_d0>0),depend(g) :: g_d0=shape(g,0)
            integer, optional,intent(in),check(g_d1>0),depend(g) :: g_d1=shape(g,1)
            integer, optional,intent(in),check(g_d2>0),depend(g) :: g_d2=shape(g,2)
            integer, optional,intent(in),check(t_d0>0),depend(t) :: t_d0=shape(t,0)
            integer, optional,intent(in),check(t_d1>0),depend(t) :: t_d1=shape(t,1)
            integer, optional,intent(in),check(t_d2>0),depend(t) :: t_d2=shape(t,2)
            integer, optional,intent(in),depend(lmax,lwin) :: corr_error_d0 = lmax-lwin+1
            integer, optional,intent(in),depend(lmax,lwin) :: admit_d0 = lmax-lwin+1
            integer, optional,intent(in),depend(lmax,lwin) :: admit_error_d0 = lmax-lwin+1
            integer, optional,intent(in),depend(lmax,lwin) :: corr_d0 = lmax-lwin+1
        end subroutine SHLocalizedAdmitCorr

        subroutine EigValVecSymTri(ain,n,eig,evec,ul,ain_d0,ain_d1,evec_d0,evec_d1,eig_d0) ! in PythonWrapper.f95
            fortranname pyeigvalvecsymtri
            use shtools, only: EigValVecSymTri
            real*8 dimension(ain_d0,ain_d1),intent(in) :: ain
            integer intent(in) :: n
            real*8 dimension(eig_d0),intent(out),depend(eig_d0) :: eig
            real*8 dimension(evec_d0,evec_d1),intent(out),depend(evec_d0,evec_d1) :: evec
            character, optional,intent(in) :: ul
            integer, optional,intent(in),check(shape(ain,0)==ain_d0),depend(ain) :: ain_d0=shape(ain,0)
            integer, optional,intent(in),check(shape(ain,1)==ain_d1),depend(ain) :: ain_d1=shape(ain,1)
            integer intent(in) :: evec_d0
            integer intent(in) :: evec_d1
            integer intent(in) :: eig_d0
        end subroutine EigValVecSymTri

        subroutine ComputeDG82(dG82,lmax,m,theta0,dG82_d0,dG82_d1) ! in PythonWrapper.f95
            fortranname pycomputedg82
            use shtools, only: ComputeDG82
            real*8 dimension(dG82_d0,dG82_d1),intent(out),depend(dG82_d0,dG82_d1) :: dG82
            integer intent(in) :: lmax
            integer intent(in) :: m
            real*8 intent(in) :: theta0
            integer, optional,intent(in),depend(lmax,m) :: dG82_d0 = lmax-abs(m)+1
            integer, optional,intent(in),depend(lmax,m) :: dG82_d1 = lmax-abs(m)+1
        end subroutine ComputeDG82

        function PlmIndex(l,m) ! in PythonWrapper.f95
            fortranname pyplmindex
            use shtools, only: PlmIndex
            integer, intent(in)  :: l
            integer, intent(in)  :: m
            integer, intent(out) :: PlmIndex
        end function PlmIndex

        function RandomN(idum) ! in PythonWrapper.f95
            fortranname pyrandomn
            use shtools, only: RandomN
            integer(kind=4) intent(inout) :: idum
            real*8 :: RandomN
        end function RandomN

        function RandomGaussian(idum) ! in PythonWrapper.f95
            fortranname pyrandomgaussian
            use shtools, only: RandomGaussian
            integer(kind=4) intent(inout) :: idum
            real*8 :: RandomGaussian
        end function RandomGaussian

        subroutine Wigner3j(w3j,jmin,jmax,j2,j3,m1,m2,m3,w3j_d0) ! in PythonWrapper.f95
            fortranname pywigner3j
            use shtools, only: Wigner3j
            real*8 dimension(w3j_d0),intent(out),depend(w3j_d0) :: w3j
            integer intent(out) :: jmin
            integer intent(out) :: jmax
            integer intent(in) :: j2
            integer intent(in) :: j3
            integer intent(in) :: m1
            integer intent(in) :: m2
            integer intent(in) :: m3
            integer intent(in) :: w3j_d0
        end subroutine Wigner3j

        subroutine SHBias(Shh,lwin,incspectra,ldata,outcspectra,save_cg,Shh_d0,incspectra_d0,outcspectra_d0) ! in PythonWrapper.f95
            fortranname pyshbias
            use shtools, only: SHBias
            real*8 dimension(Shh_d0),intent(in) :: Shh
            integer, optional,intent(in),depend(Shh_d0) :: lwin = Shh_d0-1
            real*8 dimension(incspectra_d0),intent(in) :: incspectra
            integer, optional,intent(in),depend(incspectra_d0) :: ldata = incspectra_d0-1
            real*8 dimension(outcspectra_d0),intent(out),depend(outcspectra_d0) :: outcspectra
            integer, optional,intent(in) :: save_cg = 0
            integer, optional,intent(in),check(Shh_d0>0),depend(Shh) :: Shh_d0=len(Shh)
            integer, optional,intent(in),check(len(incspectra)>=incspectra_d0),depend(incspectra) :: incspectra_d0=len(incspectra)
            integer, optional,intent(in) :: outcspectra_d0 = ldata+lwin
        end subroutine SHBias

        subroutine SHBiasK(tapers,lwin,numk,incspectra,ldata,outcspectra,taper_wt,save_cg,taper_wt_d0,tapers_d0,tapers_d1,incspectra_d0,outcspectra_d0) ! in PythonWrapper.f95
            fortranname pyshbiask
            use shtools, only: SHBiasK
            real*8 dimension(tapers_d0,tapers_d1),intent(in) :: tapers
            integer, optional,intent(in),depend(tapers_d0) :: lwin = tapers_d0-1
            integer, optional,intent(in),depend(tapers_d1) :: numk = tapers_d1
            real*8 dimension(incspectra_d0),intent(in) :: incspectra
            integer, optional,intent(in),depend(incspectra_d0) :: ldata = incspectra_d0-1
            real*8 dimension(outcspectra_d0),intent(out),depend(outcspectra_d0) :: outcspectra
            real*8, optional,dimension(taper_wt_d0),intent(in) :: taper_wt = -1
            integer, optional,intent(in) :: save_cg = 0
            integer, optional,intent(in),check(taper_wt_d0>0),depend(tapers_d1) :: taper_wt_d0=tapers_d1
            integer, optional,intent(in),check(shape(tapers,0)==tapers_d0),depend(tapers) :: tapers_d0=shape(tapers,0)
            integer, optional,intent(in),check(shape(tapers,1)==tapers_d1),depend(tapers) :: tapers_d1=shape(tapers,1)
            integer, optional,intent(in),check(len(incspectra)>=incspectra_d0),depend(incspectra) :: incspectra_d0=len(incspectra)
            integer, optional,intent(in),depend(ldata,lwin) :: outcspectra_d0 = ldata+lwin
        end subroutine SHBiasK

        function SHSjkPG0(incspectra,j,k,l,m,evec,lwin,evec_d0,evec_d1,incspectra_d0) ! in PythonWrapper.f95
            fortranname pyshsjkpg0
            use shtools, only: SHSjkPG0
            real*8 dimension(incspectra_d0),intent(in) :: incspectra
            integer intent(in) :: j
            integer intent(in) :: k
            integer intent(in) :: l
            integer intent(in) :: m
            real*8 dimension(evec_d0,evec_d1),intent(in) :: evec
            integer intent(in) :: lwin
            integer, optional,intent(in),check(shape(evec,0)==evec_d0),depend(evec) :: evec_d0=shape(evec,0)
            integer, optional,intent(in),check(shape(evec,1)==evec_d1),depend(evec) :: evec_d1=shape(evec,1)
            integer, optional,intent(in),check(len(incspectra)>=incspectra_d0),depend(incspectra) :: incspectra_d0=len(incspectra)
            real*8 :: SHSjkPG0
        end function SHSjkPG0

        subroutine SHMTVarOpt0(l,tapers,lwin,kmax,Sff,var_opt,var_unit,weight_opt,unweighted_covar,nocross,unweighted_covar_d0,unweighted_covar_d1,var_unit_d0,weight_opt_d0,weight_opt_d1,var_opt_d0,Sff_d0,tapers_d0,tapers_d1) ! in PythonWrapper.f95
            fortranname pyshmtvaropt0
            use shtools, only: SHMTVarOpt0
            integer intent(in) :: l
            real*8 dimension(tapers_d0,tapers_d1),intent(in) :: tapers
            integer intent(in) :: lwin
            integer intent(in) :: kmax
            real*8 dimension(Sff_d0),intent(in) :: Sff
            real*8 dimension(var_opt_d0),intent(out),depend(var_opt_d0) :: var_opt
            real*8 dimension(var_unit_d0),intent(out),depend(var_unit_d0) :: var_unit
            real*8, optional,dimension(weight_opt_d0,weight_opt_d1),intent(out),depend(weight_opt_d0,weight_opt_d1) :: weight_opt
            real*8, optional,dimension(unweighted_covar_d0,unweighted_covar_d1),intent(out),depend(unweighted_covar_d0,unweighted_covar_d1) :: unweighted_covar
            integer, optional,intent(in) :: nocross
            integer intent(in) :: unweighted_covar_d0
            integer intent(in) :: unweighted_covar_d1
            integer intent(in) :: var_unit_d0
            integer intent(in) :: weight_opt_d0
            integer intent(in) :: weight_opt_d1
            integer intent(in) :: var_opt_d0
            integer, optional,intent(in),check(len(Sff)>=Sff_d0),depend(Sff) :: Sff_d0=len(Sff)
            integer, optional,intent(in),check(shape(tapers,0)==tapers_d0),depend(tapers) :: tapers_d0=shape(tapers,0)
            integer, optional,intent(in),check(shape(tapers,1)==tapers_d1),depend(tapers) :: tapers_d1=shape(tapers,1)
        end subroutine SHMTVarOpt0

        subroutine SHMultiTaperSE(mtse,sd,sh,lmax,tapers,taper_order,lmaxt,K,alpha,lat,lon,taper_wt,norm,csphase,taper_order_d0,taper_wt_d0,sh_d0,sh_d1,sh_d2,alpha_d0,tapers_d0,tapers_d1,mtse_d0,sd_d0) ! in PythonWrapper.f95
            fortranname pyshmultitaperse
            use shtools, only: SHMultiTaperSE
            real*8 dimension(mtse_d0),intent(out),depend(mtse_d0) :: mtse
            real*8 dimension(sd_d0),intent(out),depend(sd_d0) :: sd
            real*8 dimension(sh_d0,sh_d1,sh_d2),intent(in) :: sh
            integer, optional,intent(in),depend(sh_d1) :: lmax = sh_d1-1
            real*8 dimension(tapers_d0,tapers_d1),intent(in) :: tapers
            integer dimension(taper_order_d0),intent(in) :: taper_order
            integer, optional,intent(in),depend(tapers_d0) :: lmaxt = tapers_d0-1
            integer, optional,intent(in),depend(tapers_d1) :: K = tapers_d1
            real*8,  optional,dimension(alpha_d0),intent(in) :: alpha = 0
            real*8,  optional,intent(in) :: lat = 0.0
            real*8,  optional,intent(in) :: lon = 0.0
            real*8,  optional,dimension(taper_wt_d0),intent(in) :: taper_wt = -1
            integer, optional,intent(in) :: norm = 1
            integer, optional,intent(in) :: csphase = 1
            integer, optional,intent(in),check(taper_order_d0>0),depend(taper_order) :: taper_order_d0=len(taper_order)
            integer, optional,intent(in),check(taper_wt_d0>0),depend(tapers_d1)    :: taper_wt_d0=tapers_d1
            integer, optional,intent(in),check(sh_d0>0),depend(sh) :: sh_d0=shape(sh,0)
            integer, optional,intent(in),check(sh_d1>0),depend(sh) :: sh_d1=shape(sh,1)
            integer, optional,intent(in),check(sh_d2>0),depend(sh) :: sh_d2=shape(sh,2)
            integer, optional,intent(in) :: alpha_d0=3
            integer, optional,intent(in),check(tapers_d0>0),depend(tapers) :: tapers_d0=shape(tapers,0)
            integer, optional,intent(in),check(tapers_d1>0),depend(tapers) :: tapers_d1=shape(tapers,1)
            integer, optional,intent(in),check(mtse_d0>0),depend(lmax,lmaxt) :: mtse_d0 = lmax - lmaxt+1
            integer, optional,intent(in),check(sd_d0>0),depend(lmax,lmaxt) :: sd_d0 = lmax-lmaxt+1
        end subroutine SHMultiTaperSE

        subroutine SHMultiTaperCSE(mtse,sd,sh1,lmax1,sh2,lmax2,tapers,taper_order,lmaxt,K,alpha,lat,lon,taper_wt,norm,csphase,sh1_d0,sh1_d1,sh1_d2,sh2_d0,sh2_d1,sh2_d2,taper_order_d0,taper_wt_d0,tapers_d0,tapers_d1,alpha_d0,sd_d0,mtse_d0) ! in PythonWrapper.f95
            fortranname pyshmultitapercse
            use shtools, only: SHMultiTaperCSE
            real*8 dimension(mtse_d0),intent(out),depend(mtse_d0) :: mtse
            real*8 dimension(sd_d0),intent(out),depend(sd_d0) :: sd
            real*8 dimension(sh1_d0,sh1_d1,sh1_d2),intent(in) :: sh1
            integer, optional,intent(in),depend(sh1_d1) :: lmax1 = sh1_d1-1
            real*8 dimension(sh2_d0,sh2_d1,sh2_d2),intent(in) :: sh2
            integer, optional,intent(in),depend(sh2_d1) :: lmax2 = sh2_d2-1
            real*8 dimension(tapers_d0,tapers_d1),intent(in) :: tapers
            integer dimension(taper_order_d0),intent(in) :: taper_order
            integer, optional,intent(in),depend(tapers_d0) :: lmaxt = tapers_d0-1
            integer, optional,intent(in),depend(tapers_d1) :: K = tapers_d1
            real*8, optional,dimension(alpha_d0),intent(in) :: alpha = 0
            real*8, optional,intent(in) :: lat = 0.0
            real*8, optional,intent(in) :: lon = 0.0
            real*8,  optional,dimension(taper_wt_d0),intent(in) :: taper_wt = -1
            integer, optional,intent(in) :: norm = 1
            integer, optional,intent(in) :: csphase = 1
            integer, optional,intent(in),check(sh1_d0>0),depend(sh1) :: sh1_d0=shape(sh1,0)
            integer, optional,intent(in),check(sh1_d1>0),depend(sh1) :: sh1_d1=shape(sh1,1)
            integer, optional,intent(in),check(sh1_d2>0),depend(sh1) :: sh1_d2=shape(sh1,2)
            integer, optional,intent(in),check(sh2_d0>0),depend(sh2) :: sh2_d0=shape(sh2,0)
            integer, optional,intent(in),check(sh2_d1>0),depend(sh2) :: sh2_d1=shape(sh2,1)
            integer, optional,intent(in),check(sh2_d2>0),depend(sh2) :: sh2_d2=shape(sh2,2)
            integer, optional,intent(in),check(taper_order_d0>0),depend(taper_order) :: taper_order_d0=len(taper_order)
            integer, optional,intent(in),check(taper_wt_d0>0),depend(tapers_d1) :: taper_wt_d0=tapers_d1
            integer, optional,intent(in),check(tapers_d0>0),depend(tapers) :: tapers_d0=shape(tapers,0)
            integer, optional,intent(in),check(tapers_d1>0),depend(tapers) :: tapers_d1=shape(tapers,1)
            integer, optional,intent(in) :: alpha_d0=3
            integer, optional,intent(in),check(sd_d0>0),depend(lmax1,lmax2,lmaxt) :: sd_d0 =  min(lmax1,lmax2)-lmaxt+1
            integer, optional,intent(in),check(mtse_d0>0),depend(lmax1,lmax2,lmaxt) :: mtse_d0 = min(lmax1,lmax2)-lmaxt+1
        end subroutine SHMultiTaperCSE

        subroutine SHReadJPL(filename,cilm,lmax,error,gm,formatstring,cilm_d0,cilm_d1,cilm_d2,error_d0,error_d1,error_d2) ! in PythonWrapper.f95
            fortranname pyshreadjpl
            use shtools, only: SHReadJPL
            character*(*) intent(in) :: filename
            real*8 dimension(cilm_d0,cilm_d1,cilm_d2),intent(out),depend(cilm_d0,cilm_d1,cilm_d2) :: cilm
            integer intent(in) :: lmax
            real*8, optional,dimension(error_d0,error_d1,error_d2),intent(out),depend(error_d0,error_d1,error_d2) :: error
            real*8, optional,dimension(2),intent(out) :: gm
            character*6, optional,intent(in) :: formatstring
            integer intent(in) :: cilm_d0
            integer intent(in) :: cilm_d1
            integer intent(in) :: cilm_d2
            integer intent(in) :: error_d0
            integer intent(in) :: error_d1
            integer intent(in) :: error_d2
        end subroutine SHReadJPL

        subroutine SHRead2(filename,cilm,lmax,gm,r0_pot,error,dot,doystart,doyend,epoch,cilm_d0,cilm_d1,cilm_d2,error_d0,error_d1,error_d2,dot_d0,dot_d1,dot_d2) ! in PythonWrapper.f95
            fortranname pyshread2
            use shtools, only: SHRead2
            character*(*) intent(in) :: filename
            real*8 dimension(cilm_d0,cilm_d1,cilm_d2),intent(out),depend(cilm_d0,cilm_d1,cilm_d2) :: cilm
            integer intent(out) :: lmax
            real*8 intent(out) :: gm
            real*8 intent(out) :: r0_pot
            real*8, optional,dimension(error_d0,error_d1,error_d2),intent(out),depend(error_d0,error_d1,error_d2) :: error
            real*8, optional,dimension(dot_d0,dot_d1,dot_d2),intent(out),depend(dot_d0,dot_d1,dot_d2) :: dot
            real*8, optional,intent(out) :: doystart
            real*8, optional,intent(out) :: doyend
            real*8, optional,intent(out) :: epoch
            integer intent(in) :: cilm_d0
            integer intent(in) :: cilm_d1
            integer intent(in) :: cilm_d2
            integer intent(in) :: error_d0
            integer intent(in) :: error_d1
            integer intent(in) :: error_d2
            integer intent(in) :: dot_d0
            integer intent(in) :: dot_d1
            integer intent(in) :: dot_d2
        end subroutine SHRead2

        subroutine MakeGeoidGrid(geoid,cilm,lmax,r0pot,GM,PotRef,omega,r,gridtype,order,nlat,nlong,interval,lmax_calc,a,f,cilm_d0,cilm_d1,cilm_d2,geoid_d0,geoid_d1) ! in PythonWrapper.f95
            fortranname pymakegeoidgrid
            use shtools, only: MakeGeoidGrid
            real*8 dimension(geoid_d0,geoid_d1),intent(out),depend(geoid_d0,geoid_d1) :: geoid
            real*8 dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            integer intent(in) :: lmax
            real*8 intent(in) :: r0pot
            real*8 intent(in) :: GM
            real*8 intent(in) :: PotRef
            real*8 intent(in) :: omega
            real*8 intent(in) :: r
            integer intent(in) :: gridtype
            integer intent(in) :: order
            integer intent(out) :: nlat
            integer intent(out) :: nlong
            real*8, optional,intent(in) :: interval
            integer, optional,intent(in) :: lmax_calc
            real*8, optional,intent(in) :: a
            real*8, optional,intent(in) :: f
            integer, optional,intent(in),check(shape(cilm,0)==cilm_d0),depend(cilm) :: cilm_d0=shape(cilm,0)
            integer, optional,intent(in),check(shape(cilm,1)==cilm_d1),depend(cilm) :: cilm_d1=shape(cilm,1)
            integer, optional,intent(in),check(shape(cilm,2)==cilm_d2),depend(cilm) :: cilm_d2=shape(cilm,2)
            integer intent(in) :: geoid_d0
            integer intent(in) :: geoid_d1
        end subroutine MakeGeoidGrid

        subroutine PlmON(p,lmax,z,csphase,cnorm,p_d0) ! in PythonWrapper.f95
            fortranname pyplmon
            use shtools, only: PlmON
            real*8 dimension(p_d0),intent(out),depend(p_d0) :: p
            integer intent(in) :: lmax
            real*8 intent(in) :: z
            integer, optional,intent(in) :: csphase = 1
            integer, optional,intent(in) :: cnorm = 0
            integer intent(hide),depend(lmax) :: p_d0 = (lmax+1)*(lmax+2)/2
        end subroutine PlmON

        subroutine PlON(p,lmax,z,p_d0) ! in PythonWrapper.f95
            fortranname pyplon
            use shtools, only: PlON
            real*8 dimension(p_d0),intent(out),depend(p_d0) :: p
            integer intent(in) :: lmax
            real*8 intent(in) :: z
            integer intent(hide),depend(lmax) :: p_d0 = lmax+1
        end subroutine PlON

        subroutine PlmON_d1(p,dp,lmax,z,csphase,cnorm,p_d0,dp_d0) ! in PythonWrapper.f95
            fortranname pyplmon_d1
            use shtools, only: PlmON_d1
            real*8 dimension(p_d0),intent(out),depend(p_d0) :: p
            real*8 dimension(dp_d0),intent(out),depend(dp_d0) :: dp
            integer intent(in) :: lmax
            real*8 intent(in) :: z
            integer, optional,intent(in) :: csphase = 1
            integer, optional,intent(in) :: cnorm = 0
            integer intent(hide),depend(lmax) :: p_d0  = (lmax+1)*(lmax+2)/2
            integer intent(hide),depend(lmax) :: dp_d0 = (lmax+1)*(lmax+2)/2
        end subroutine PlmON_d1

        subroutine PlON_d1(p,dp,lmax,z,p_d0,dp_d0) ! in PythonWrapper.f95
            fortranname pyplon_d1
            use shtools, only: PlON_d1
            real*8 dimension(p_d0),intent(out),depend(p_d0) :: p
            real*8 dimension(dp_d0),intent(out),depend(dp_d0) :: dp
            integer intent(in) :: lmax
            real*8 intent(in) :: z
            integer intent(hide),depend(lmax) :: p_d0  = lmax+1
            integer intent(hide),depend(lmax) :: dp_d0 = lmax+1
        end subroutine PlON_d1

        subroutine MakeCircleCoord(coord,lat,lon,theta0,cinterval,cnum,coord_d0,coord_d1) ! in PythonWrapper.f95
            fortranname pymakecirclecoord
            use shtools, only: MakeCircleCoord
            real*8 dimension(coord_d0,coord_d1),intent(out),depend(coord_d0,coord_d1) :: coord
            real*8 intent(in) :: lat
            real*8 intent(in) :: lon
            real*8 intent(in) :: theta0
            real*8, optional,intent(in) :: cinterval
            integer, optional,intent(out) :: cnum
            integer intent(in) :: coord_d0
            integer intent(in) :: coord_d1
        end subroutine MakeCircleCoord

        subroutine SHReturnTapers(theta0,lmax,tapers,eigenvalues,taper_order,eigenvalues_d0,tapers_d0,tapers_d1,taper_order_d0) ! in PythonWrapper.f95
            fortranname pyshreturntapers
            use shtools, only: SHReturnTapers
            real*8 intent(in) :: theta0
            integer intent(in) :: lmax
            real*8 dimension(tapers_d0,tapers_d1),intent(out),depend(tapers_d0,tapers_d1) :: tapers
            real*8 dimension(eigenvalues_d0),intent(out),depend(eigenvalues_d0) :: eigenvalues
            integer dimension(taper_order_d0),intent(out),depend(taper_order_d0) :: taper_order
            integer, optional,intent(in),depend(lmax) :: eigenvalues_d0 = (lmax+1)*(lmax+1)
            integer, optional,intent(in),depend(lmax) :: tapers_d0 = (lmax+1)
            integer, optional,intent(in),depend(lmax) :: tapers_d1 = (lmax+1)*(lmax+1)
            integer, optional,intent(in),depend(lmax) :: taper_order_d0 = (lmax+1)*(lmax+1)
        end subroutine SHReturnTapers

        function SHSjkPG(incspectra,l,m,mprime,hj_real,hk_real,mj,mk,lwin,hkcc,hk_real_d0,incspectra_d0,hj_real_d0) ! in PythonWrapper.f95
            fortranname pyshsjkpg
            use shtools, only: SHSjkPG
            real*8 dimension(incspectra_d0),intent(in) :: incspectra
            integer intent(in) :: l
            integer intent(in) :: m
            integer intent(in) :: mprime
            real*8 dimension(hj_real_d0),intent(in) :: hj_real
            real*8 dimension(hk_real_d0),intent(in) :: hk_real
            integer intent(in) :: mj
            integer intent(in) :: mk
            integer intent(in) :: lwin
            integer intent(in) :: hkcc
            integer, optional,intent(in),check(len(hk_real)>=hk_real_d0),depend(hk_real) :: hk_real_d0=len(hk_real)
            integer, optional,intent(in),check(len(incspectra)>=incspectra_d0),depend(incspectra) :: incspectra_d0=len(incspectra)
            integer, optional,intent(in),check(len(hj_real)>=hj_real_d0),depend(hj_real) :: hj_real_d0=len(hj_real)
            complex*16 :: SHSjkPG
        end function SHSjkPG

        subroutine SHMTVarOpt(l,tapers,taper_order,lwin,kmax,Sff,var_opt,var_unit,weight_opt,unweighted_covar,nocross,unweighted_covar_d0,unweighted_covar_d1,taper_order_d0,weight_opt_d0,weight_opt_d1,var_unit_d0,var_opt_d0,Sff_d0,tapers_d0,tapers_d1) ! in PythonWrapper.f95
            fortranname pyshmtvaropt
            use shtools, only: SHMTVarOpt
            integer intent(in) :: l
            real*8 dimension(tapers_d0,tapers_d1),intent(in) :: tapers
            integer dimension(taper_order_d0),intent(in) :: taper_order
            integer intent(in) :: lwin
            integer intent(in) :: kmax
            real*8 dimension(Sff_d0),intent(in) :: Sff
            real*8 dimension(var_opt_d0),intent(out),depend(var_opt_d0) :: var_opt
            real*8 dimension(var_unit_d0),intent(out),depend(var_unit_d0) :: var_unit
            real*8, optional,dimension(weight_opt_d0,weight_opt_d1),intent(out),depend(weight_opt_d0,weight_opt_d1) :: weight_opt
            real*8, optional,dimension(unweighted_covar_d0,unweighted_covar_d1),intent(out),depend(unweighted_covar_d0,unweighted_covar_d1) :: unweighted_covar
            integer, optional,intent(in) :: nocross
            integer intent(in) :: unweighted_covar_d0
            integer intent(in) :: unweighted_covar_d1
            integer, optional,intent(in),check(len(taper_order)>=taper_order_d0),depend(taper_order) :: taper_order_d0=len(taper_order)
            integer intent(in) :: weight_opt_d0
            integer intent(in) :: weight_opt_d1
            integer intent(in) :: var_unit_d0
            integer intent(in) :: var_opt_d0
            integer, optional,intent(in),check(len(Sff)>=Sff_d0),depend(Sff) :: Sff_d0=len(Sff)
            integer, optional,intent(in),check(shape(tapers,0)==tapers_d0),depend(tapers) :: tapers_d0=shape(tapers,0)
            integer, optional,intent(in),check(shape(tapers,1)==tapers_d1),depend(tapers) :: tapers_d1=shape(tapers,1)
        end subroutine SHMTVarOpt

        subroutine SHMTDebias(mtdebias,mtspectra,lmax,tapers,lwin,K,nl,lmid,n,taper_wt,mtdebias_d0,mtdebias_d1,taper_wt_d0,mtspectra_d0,mtspectra_d1,tapers_d0,tapers_d1,lmid_d0) ! in PythonWrapper.f95
            fortranname pyshmtdebias
            use shtools, only: SHMTDebias
            real*8 dimension(mtdebias_d0,mtdebias_d1),intent(out),depend(mtdebias_d0,mtdebias_d1) :: mtdebias
            real*8 dimension(mtspectra_d0,mtspectra_d1),intent(in) :: mtspectra
            integer intent(in) :: lmax
            real*8 dimension(tapers_d0,tapers_d1),intent(in) :: tapers
            integer intent(in) :: lwin
            integer intent(in) :: K
            integer intent(in) :: nl
            real*8 dimension(lmid_d0),intent(out),depend(lmid_d0) :: lmid
            integer intent(out) :: n
            real*8, optional,dimension(taper_wt_d0),intent(in) :: taper_wt
            integer intent(in) :: mtdebias_d0
            integer intent(in) :: mtdebias_d1
            integer, optional,intent(in),check(len(taper_wt)>=taper_wt_d0),depend(taper_wt) :: taper_wt_d0=len(taper_wt)
            integer, optional,intent(in),check(shape(mtspectra,0)==mtspectra_d0),depend(mtspectra) :: mtspectra_d0=shape(mtspectra,0)
            integer, optional,intent(in),check(shape(mtspectra,1)==mtspectra_d1),depend(mtspectra) :: mtspectra_d1=shape(mtspectra,1)
            integer, optional,intent(in),check(shape(tapers,0)==tapers_d0),depend(tapers) :: tapers_d0=shape(tapers,0)
            integer, optional,intent(in),check(shape(tapers,1)==tapers_d1),depend(tapers) :: tapers_d1=shape(tapers,1)
            integer intent(in) :: lmid_d0
        end subroutine SHMTDebias

        subroutine MakeGravGridDH(cilm,lmax,gm,r0,a,f,rad,theta,phi,total,n,sampling,lmax_calc,omega,normal_gravity,pot,phi_d0,phi_d1,total_d0,total_d1,pot_d0,pot_d1,rad_d0,rad_d1,cilm_d0,cilm_d1,cilm_d2,theta_d0,theta_d1) ! in PythonWrapper.f95
            fortranname pymakegravgriddh
            use shtools, only: MakeGravGridDH
            real*8 dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            integer intent(in) :: lmax
            real*8 intent(in) :: gm
            real*8 intent(in) :: r0
            real*8 intent(in) :: a
            real*8 intent(in) :: f
            real*8 dimension(rad_d0,rad_d1),intent(out),depend(rad_d0,rad_d1) :: rad
            real*8 dimension(theta_d0,theta_d1),intent(out),depend(theta_d0,theta_d1) :: theta
            real*8 dimension(phi_d0,phi_d1),intent(out),depend(phi_d0,phi_d1) :: phi
            real*8 dimension(total_d0,total_d1),intent(out),depend(total_d0,total_d1) :: total
            integer intent(out) :: n
            integer, optional,intent(in) :: sampling
            integer, optional,intent(in) :: lmax_calc
            real*8, optional,intent(in) :: omega
            integer, optional,intent(in) :: normal_gravity
            real*8, optional,dimension(pot_d0,pot_d1),intent(out),depend(pot_d0,pot_d1) :: pot
            integer intent(in) :: phi_d0
            integer intent(in) :: phi_d1
            integer intent(in) :: total_d0
            integer intent(in) :: total_d1
            integer intent(in) :: pot_d0
            integer intent(in) :: pot_d1
            integer intent(in) :: rad_d0
            integer intent(in) :: rad_d1
            integer, optional,intent(in),check(shape(cilm,0)==cilm_d0),depend(cilm) :: cilm_d0=shape(cilm,0)
            integer, optional,intent(in),check(shape(cilm,1)==cilm_d1),depend(cilm) :: cilm_d1=shape(cilm,1)
            integer, optional,intent(in),check(shape(cilm,2)==cilm_d2),depend(cilm) :: cilm_d2=shape(cilm,2)
            integer intent(in) :: theta_d0
            integer intent(in) :: theta_d1
        end subroutine MakeGravGridDH

        function NormalGravity(geocentric_lat,gm,omega,a,b) ! in PythonWrapper.f95
            fortranname pynormalgravity
            use shtools, only: NormalGravity
            real*8 intent(in) :: geocentric_lat
            real*8 intent(in) :: gm
            real*8 intent(in) :: omega
            real*8 intent(in) :: a
            real*8 intent(in) :: b
            real*8 :: NormalGravity
        end function NormalGravity

        function SHConfidence(l_conf,r) ! in PythonWrapper.f95
            fortranname pyshconfidence
            use shtools, only: SHConfidence
            integer intent(in) :: l_conf
            real*8 intent(in) :: r
            real*8 :: SHConfidence
        end function SHConfidence

        function SHMagPowerL(c,a,r,l,c_d0,c_d1,c_d2) ! in PythonWrapper.f95
            fortranname pyshmagpowerl
            use shtools, only: SHMagPowerL
            real*8 dimension(c_d0,c_d1,c_d2),intent(in) :: c
            real*8 intent(in) :: a
            real*8 intent(in) :: r
            integer intent(in) :: l
            integer, optional,intent(in),check(shape(c,0)==c_d0),depend(c) :: c_d0=shape(c,0)
            integer, optional,intent(in),check(shape(c,1)==c_d1),depend(c) :: c_d1=shape(c,1)
            integer, optional,intent(in),check(shape(c,2)==c_d2),depend(c) :: c_d2=shape(c,2)
            real*8 :: SHMagPowerL
        end function SHMagPowerL

        subroutine SHMagPowerSpectrum(c,a,r,lmax,spectra,c_d0,c_d1,c_d2,spectra_d0) ! in PythonWrapper.f95
            fortranname pyshmagpowerspectrum
            use shtools, only: SHMagPowerSpectrum
            real*8 dimension(c_d0,c_d1,c_d2),intent(in) :: c
            real*8 intent(in) :: a
            real*8 intent(in) :: r
            integer intent(in) :: lmax
            real*8 dimension(spectra_d0),intent(out),depend(spectra_d0) :: spectra
            integer, optional,intent(in),check(shape(c,0)==c_d0),depend(c) :: c_d0=shape(c,0)
            integer, optional,intent(in),check(shape(c,1)==c_d1),depend(c) :: c_d1=shape(c,1)
            integer, optional,intent(in),check(shape(c,2)==c_d2),depend(c) :: c_d2=shape(c,2)
            integer intent(in) :: spectra_d0
        end subroutine SHMagPowerSpectrum

        subroutine SHExpandDHC(grid,n,cilm,lmax,norm,sampling,csphase,lmax_calc,cilm_d0,cilm_d1,cilm_d2,grid_d0,grid_d1) ! in PythonWrapper.f95
            fortranname pyshexpanddhc
            use shtools, only: SHExpandDHC
            complex*16 dimension(grid_d0,grid_d1),intent(in) :: grid
            integer, optional,intent(in),depend(grid_d0) :: n=grid_d0
            complex*16 dimension(cilm_d0,cilm_d1,cilm_d2),intent(out),depend(cilm_d0,cilm_d1,cilm_d2) :: cilm
            integer intent(hide) :: lmax
            integer, optional,intent(in) :: norm = 1
            integer, optional,intent(in) :: sampling = 1
            integer, optional,intent(in) :: csphase = 1
            integer, optional,intent(in),depend(n) :: lmax_calc = n/2-1
            integer, optional,intent(in) :: cilm_d0=2
            integer, optional,intent(in),depend(n) :: cilm_d1=n/2
            integer, optional,intent(in),depend(n) :: cilm_d2=n/2
            integer, optional,intent(in),check(shape(grid,0)==grid_d0),depend(grid) :: grid_d0=shape(grid,0)
            integer, optional,intent(in),check(shape(grid,1)==grid_d1),depend(grid) :: grid_d1=shape(grid,1)
        end subroutine SHExpandDHC

        subroutine MakeGridDHC(griddh,n,cilm,lmax,norm,sampling,csphase,lmax_calc,cilm_d0,cilm_d1,cilm_d2,griddh_d0,griddh_d1) ! in PythonWrapper.f95
            fortranname pymakegriddhc
            use shtools, only: MakeGridDHC
            complex*16 dimension(griddh_d0,griddh_d1),intent(out),depend(griddh_d0,griddh_d1) :: griddh
            integer intent(hide) :: n
            complex*16 dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            integer, optional,intent(in),depend(cilm_d1) :: lmax=cilm_d1-1
            integer, optional,intent(in) :: norm=1
            integer, optional,intent(in) :: sampling=1
            integer, optional,intent(in) :: csphase=1
            integer, optional,intent(in),depend(lmax) :: lmax_calc=lmax
            integer, optional,intent(in),check(shape(cilm,0)==cilm_d0),depend(cilm) :: cilm_d0=shape(cilm,0)
            integer, optional,intent(in),check(shape(cilm,1)==cilm_d1),depend(cilm) :: cilm_d1=shape(cilm,1)
            integer, optional,intent(in),check(shape(cilm,2)==cilm_d2),depend(cilm) :: cilm_d2=shape(cilm,2)
            integer, optional,intent(in),depend(lmax) :: griddh_d0=2*(lmax+1)
            integer, optional,intent(in),depend(griddh_d0,sampling) :: griddh_d1=sampling*griddh_d0
        end subroutine MakeGridDHC

        subroutine MakeGridGLQC(gridglq,cilm,lmax,zero,norm,csphase,lmax_calc,gridglq_d0,gridglq_d1,cilm_d0,cilm_d1,cilm_d2,zero_d0) ! in PythonWrapper.f95
            fortranname pymakegridglqc
            use shtools, only: MakeGridGLQC
            complex*16 dimension(gridglq_d0,gridglq_d1),intent(out),depend(gridglq_d0,gridglq_d1) :: gridglq
            complex*16 dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            integer, optional,intent(in),depend(cilm_d1) :: lmax = cilm_d1-1
            real*8, dimension(zero_d0),intent(in) :: zero
            integer, optional,intent(in) :: norm = 1
            integer, optional,intent(in) :: csphase = 1
            integer, optional,intent(in),depend(lmax) :: lmax_calc = lmax
            integer, optional,intent(in),depend(lmax) :: gridglq_d0 = lmax+1
            integer, optional,intent(in),depend(lmax) :: gridglq_d1 = 2*lmax+1
            integer, optional,intent(in),check(shape(cilm,0)==cilm_d0),depend(cilm) :: cilm_d0=shape(cilm,0)
            integer, optional,intent(in),check(shape(cilm,1)==cilm_d1),depend(cilm) :: cilm_d1=shape(cilm,1)
            integer, optional,intent(in),check(shape(cilm,2)==cilm_d2),depend(cilm) :: cilm_d2=shape(cilm,2)
            integer, optional,intent(in),check(len(zero)>=zero_d0),depend(zero) :: zero_d0=len(zero)
        end subroutine MakeGridGLQC

        subroutine SHExpandGLQC(cilm,lmax,gridglq,w,zero,norm,csphase,lmax_calc,cilm_d0,cilm_d1,cilm_d2,gridglq_d0,gridglq_d1,zero_d0,w_d0) ! in PythonWrapper.f95
            fortranname pyshexpandglqc
            use shtools, only: SHExpandGLQC
            complex*16 dimension(cilm_d0,cilm_d1,cilm_d2),intent(out),depend(cilm_d0,cilm_d1,cilm_d2) :: cilm
            complex*16 dimension(gridglq_d0,gridglq_d1),intent(in) :: gridglq
            real*8 dimension(w_d0),intent(in) :: w
            real*8, dimension(zero_d0),intent(in) :: zero
            integer, optional,intent(in),depend(gridglq_d0) :: lmax=gridglq_d0-1
            integer, optional,intent(in) :: norm = 1
            integer, optional,intent(in) :: csphase = 1
            integer, optional,intent(in),depend(lmax) :: lmax_calc = lmax
            integer, optional,intent(in) :: cilm_d0 = 2
            integer, optional,intent(in),depend(lmax) :: cilm_d1 = lmax+1
            integer, optional,intent(in),depend(lmax) :: cilm_d2 = lmax+1
            integer, optional,intent(in),depend(gridglq) :: gridglq_d0=shape(gridglq,0)
            integer, optional,intent(in),depend(gridglq) :: gridglq_d1=shape(gridglq,1)
            integer, optional,intent(in),depend(zero) :: zero_d0=len(zero)
            integer, optional,intent(in),check(len(w)>=w_d0),depend(w) :: w_d0=len(w)
        end subroutine SHExpandGLQC

        function SHPowerLC(c,l,c_d0,c_d1,c_d2) ! in PythonWrapper.f95
            fortranname pyshpowerlc
            use shtools, only: SHPowerLC
            complex*16 dimension(c_d0,c_d1,c_d2),intent(in) :: c
            integer intent(in) :: l
            integer, optional,intent(in),check(shape(c,0)==c_d0),depend(c) :: c_d0=shape(c,0)
            integer, optional,intent(in),check(shape(c,1)==c_d1),depend(c) :: c_d1=shape(c,1)
            integer, optional,intent(in),check(shape(c,2)==c_d2),depend(c) :: c_d2=shape(c,2)
            real*8 :: SHPowerLC
        end function SHPowerLC

        function SHPowerDensityLC(c,l,c_d0,c_d1,c_d2) ! in PythonWrapper.f95
            fortranname pyshpowerdensitylc
            use shtools, only: SHPowerDensityLC
            complex*16 dimension(c_d0,c_d1,c_d2),intent(in) :: c
            integer intent(in) :: l
            integer, optional,intent(in),check(shape(c,0)==c_d0),depend(c) :: c_d0=shape(c,0)
            integer, optional,intent(in),check(shape(c,1)==c_d1),depend(c) :: c_d1=shape(c,1)
            integer, optional,intent(in),check(shape(c,2)==c_d2),depend(c) :: c_d2=shape(c,2)
            real*8 :: SHPowerDensityLC
        end function SHPowerDensityLC

        function SHCrossPowerLC(c1,c2,l,c2_d0,c2_d1,c2_d2,c1_d0,c1_d1,c1_d2) ! in PythonWrapper.f95
            fortranname pyshcrosspowerlc
            use shtools, only: SHCrossPowerLC
            complex*16 dimension(c1_d0,c1_d1,c1_d2),intent(in) :: c1
            complex*16 dimension(c2_d0,c2_d1,c2_d2),intent(in) :: c2
            integer intent(in) :: l
            integer, optional,intent(in),check(shape(c2,0)==c2_d0),depend(c2) :: c2_d0=shape(c2,0)
            integer, optional,intent(in),check(shape(c2,1)==c2_d1),depend(c2) :: c2_d1=shape(c2,1)
            integer, optional,intent(in),check(shape(c2,2)==c2_d2),depend(c2) :: c2_d2=shape(c2,2)
            integer, optional,intent(in),check(shape(c1,0)==c1_d0),depend(c1) :: c1_d0=shape(c1,0)
            integer, optional,intent(in),check(shape(c1,1)==c1_d1),depend(c1) :: c1_d1=shape(c1,1)
            integer, optional,intent(in),check(shape(c1,2)==c1_d2),depend(c1) :: c1_d2=shape(c1,2)
            complex*16 :: SHCrossPowerLC
        end function SHCrossPowerLC

        function SHCrossPowerDensityLC(c1,c2,l,c2_d0,c2_d1,c2_d2,c1_d0,c1_d1,c1_d2) ! in PythonWrapper.f95
            fortranname pyshcrosspowerdensitylc
            use shtools, only: SHCrossPowerDensityLC
            complex*16 dimension(c1_d0,c1_d1,c1_d2),intent(in) :: c1
            complex*16 dimension(c2_d0,c2_d1,c2_d2),intent(in) :: c2
            integer intent(in) :: l
            integer, optional,intent(in),check(shape(c2,0)==c2_d0),depend(c2) :: c2_d0=shape(c2,0)
            integer, optional,intent(in),check(shape(c2,1)==c2_d1),depend(c2) :: c2_d1=shape(c2,1)
            integer, optional,intent(in),check(shape(c2,2)==c2_d2),depend(c2) :: c2_d2=shape(c2,2)
            integer, optional,intent(in),check(shape(c1,0)==c1_d0),depend(c1) :: c1_d0=shape(c1,0)
            integer, optional,intent(in),check(shape(c1,1)==c1_d1),depend(c1) :: c1_d1=shape(c1,1)
            integer, optional,intent(in),check(shape(c1,2)==c1_d2),depend(c1) :: c1_d2=shape(c1,2)
            complex*16 :: SHCrossPowerDensityLC
        end function SHCrossPowerDensityLC

        subroutine SHPowerSpectrumC(c,lmax,spectra,c_d0,c_d1,c_d2,spectra_d0) ! in PythonWrapper.f95
            fortranname pyshpowerspectrumc
            use shtools, only: SHPowerSpectrumC
            complex*16 dimension(c_d0,c_d1,c_d2),intent(in) :: c
            integer, optional,intent(in),depend(c_d1) :: lmax = c_d1-1
            real*8 dimension(spectra_d0),intent(out),depend(spectra_d0) :: spectra
            integer, optional,intent(in),check(shape(c,0)==c_d0),depend(c) :: c_d0=shape(c,0)
            integer, optional,intent(in),check(shape(c,1)==c_d1),depend(c) :: c_d1=shape(c,1)
            integer, optional,intent(in),check(shape(c,2)==c_d2),depend(c) :: c_d2=shape(c,2)
            integer, optional,intent(in),depend(lmax) :: spectra_d0 = lmax+1
        end subroutine SHPowerSpectrumC

        subroutine SHPowerSpectrumDensityC(c,lmax,spectra,c_d0,c_d1,c_d2,spectra_d0) ! in PythonWrapper.f95
            fortranname pyshpowerspectrumdensityc
            use shtools, only: SHPowerSpectrumDensityC
            complex*16 dimension(c_d0,c_d1,c_d2),intent(in) :: c
            integer, optional,intent(in),depend(c_d1) :: lmax = c_d1-1
            real*8 dimension(spectra_d0),intent(out),depend(spectra_d0) :: spectra
            integer, optional,intent(in),check(shape(c,0)==c_d0),depend(c) :: c_d0=shape(c,0)
            integer, optional,intent(in),check(shape(c,1)==c_d1),depend(c) :: c_d1=shape(c,1)
            integer, optional,intent(in),check(shape(c,2)==c_d2),depend(c) :: c_d2=shape(c,2)
            integer, optional,intent(in),depend(lmax) :: spectra_d0 = lmax+1
        end subroutine SHPowerSpectrumDensityC

        subroutine SHCrossPowerSpectrumC(c1,c2,lmax,cspectra,c2_d0,c2_d1,c2_d2,c1_d0,c1_d1,c1_d2,cspectra_d0) ! in PythonWrapper.f95
            fortranname pyshcrosspowerspectrumc
            use shtools, only: SHCrossPowerSpectrumC
            complex*16 dimension(c1_d0,c1_d1,c1_d2),intent(in) :: c1
            complex*16 dimension(c2_d0,c2_d1,c2_d2),intent(in) :: c2
            integer, optional, intent(in),depend(c1_d1,c2_d1) :: lmax = min(c1_d1,c2_d1)-1
            complex*16 dimension(cspectra_d0),intent(out),depend(cspectra_d0) :: cspectra
            integer, optional,intent(in),check(shape(c2,0)==c2_d0),depend(c2) :: c2_d0=shape(c2,0)
            integer, optional,intent(in),check(shape(c2,1)==c2_d1),depend(c2) :: c2_d1=shape(c2,1)
            integer, optional,intent(in),check(shape(c2,2)==c2_d2),depend(c2) :: c2_d2=shape(c2,2)
            integer, optional,intent(in),check(shape(c1,0)==c1_d0),depend(c1) :: c1_d0=shape(c1,0)
            integer, optional,intent(in),check(shape(c1,1)==c1_d1),depend(c1) :: c1_d1=shape(c1,1)
            integer, optional,intent(in),check(shape(c1,2)==c1_d2),depend(c1) :: c1_d2=shape(c1,2)
            integer, optioanl,intent(in),depend(lmax) :: cspectra_d0 = lmax+1
        end subroutine SHCrossPowerSpectrumC

        subroutine SHCrossPowerSpectrumDensityC(c1,c2,lmax,cspectra,c2_d0,c2_d1,c2_d2,c1_d0,c1_d1,c1_d2,cspectra_d0) ! in PythonWrapper.f95
            fortranname pyshcrosspowerspectrumdensityc
            use shtools, only: SHCrossPowerSpectrumDensityC
            complex*16 dimension(c1_d0,c1_d1,c1_d2),intent(in) :: c1
            complex*16 dimension(c2_d0,c2_d1,c2_d2),intent(in) :: c2
            integer, optional, intent(in),depend(c1_d1,c2_d1) :: lmax = min(c1_d1,c2_d1)-1
            complex*16 dimension(cspectra_d0),intent(out),depend(cspectra_d0) :: cspectra
            integer, optional,intent(in),check(shape(c2,0)==c2_d0),depend(c2) :: c2_d0=shape(c2,0)
            integer, optional,intent(in),check(shape(c2,1)==c2_d1),depend(c2) :: c2_d1=shape(c2,1)
            integer, optional,intent(in),check(shape(c2,2)==c2_d2),depend(c2) :: c2_d2=shape(c2,2)
            integer, optional,intent(in),check(shape(c1,0)==c1_d0),depend(c1) :: c1_d0=shape(c1,0)
            integer, optional,intent(in),check(shape(c1,1)==c1_d1),depend(c1) :: c1_d1=shape(c1,1)
            integer, optional,intent(in),check(shape(c1,2)==c1_d2),depend(c1) :: c1_d2=shape(c1,2)
            integer, optioanl,intent(in),depend(lmax) :: cspectra_d0 = lmax+1
        end subroutine SHCrossPowerSpectrumDensityC

        subroutine SHBiasAdmitCorr(sgt,sgg,stt,lmax,tapers,lwin,K,admit,corr,mtdef,taper_wt,taper_wt_d0,sgt_d0,stt_d0,admit_d0,tapers_d0,tapers_d1,corr_d0,sgg_d0) ! in PythonWrapper.f95
            fortranname pyshbiasadmitcorr
            use shtools, only: SHBiasAdmitCorr
            real*8 dimension(sgt_d0),intent(in) :: sgt
            real*8 dimension(sgg_d0),intent(in) :: sgg
            real*8 dimension(stt_d0),intent(in) :: stt
            integer, optional,intent(in),depend(sgt_d0) :: lmax = sgt_d0-1
            real*8 dimension(tapers_d0,tapers_d1),intent(in) :: tapers
            integer, optional,intent(in),depend(tapers_d0) :: lwin = tapers_d0-1
            integer, optional,intent(in),depend(tapers_d1) :: K = tapers_d1
            real*8 dimension(admit_d0),intent(out),depend(admit_d0) :: admit
            real*8 dimension(corr_d0),intent(out),depend(corr_d0) :: corr
            integer, optional,intent(in) :: mtdef = 0
            real*8, optional,dimension(taper_wt_d0),intent(in) :: taper_wt
            integer, optional,intent(in),check(taper_wt_d0>0),depend(tapers_d1) :: taper_wt_d0=tapers_d1
            integer, optional,intent(in),check(len(sgt)>=sgt_d0),depend(sgt) :: sgt_d0=len(sgt)
            integer, optional,intent(in),check(len(stt)>=stt_d0),depend(stt) :: stt_d0=len(stt)
            integer intent(in) :: admit_d0
            integer, optional,intent(in),check(shape(tapers,0)==tapers_d0),depend(tapers) :: tapers_d0=shape(tapers,0)
            integer, optional,intent(in),check(shape(tapers,1)==tapers_d1),depend(tapers) :: tapers_d1=shape(tapers,1)
            integer intent(in) :: corr_d0
            integer, optional,intent(in),check(len(sgg)>=sgg_d0),depend(sgg) :: sgg_d0=len(sgg)
        end subroutine SHBiasAdmitCorr

        subroutine SHCilmToVector(cilm,vector,lmax,vector_d0,cilm_d0,cilm_d1,cilm_d2) ! in PythonWrapper.f95
            fortranname pyshcilmtovector
            use shtools, only: SHCilmToVector
            real*8 dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            real*8 dimension(vector_d0),intent(out),depend(vector_d0) :: vector
            integer, optional,intent(in) :: lmax = cilm_d1-1
            integer, optional,intent(in),depend(lmax) :: vector_d0 = (lmax+1)*(lmax+1)
            integer, optional,intent(in),check(shape(cilm,0)==cilm_d0),depend(cilm) :: cilm_d0=shape(cilm,0)
            integer, optional,intent(in),check(shape(cilm,1)==cilm_d1),depend(cilm) :: cilm_d1=shape(cilm,1)
            integer, optional,intent(in),check(shape(cilm,2)==cilm_d2),depend(cilm) :: cilm_d2=shape(cilm,2)
        end subroutine SHCilmToVector

        subroutine SHVectorToCilm(vector,cilm,lmax,vector_d0,cilm_d0,cilm_d1,cilm_d2) ! in PythonWrapper.f95
            fortranname pyshvectortocilm
            use shtools, only: SHVectorToCilm
            real*8 dimension(vector_d0),intent(in) :: vector
            real*8 dimension(cilm_d0,cilm_d1,cilm_d2),intent(out),depend(cilm_d0,cilm_d1,cilm_d2) :: cilm
            integer intent(in) :: lmax = sqrt(vector_d0)-1
            integer, optional,intent(in),check(len(vector)>=vector_d0),depend(vector) :: vector_d0=len(vector)
            integer, optional,intent(in) :: cilm_d0 = 2
            integer, optional,intent(in),depend(lmax) :: cilm_d1 = lmax+1
            integer, optional,intent(in),depend(lmax) :: cilm_d2 = lmax+1
        end subroutine SHVectorToCilm

        function YilmIndex(i,l,m) ! in PythonWrapper.f95
            fortranname pyyilmindex
            use shtools, only: YilmIndex
            integer intent(in) :: i
            integer intent(in) :: l
            integer intent(in) :: m
            integer :: YilmIndex
        end function YilmIndex

        subroutine ComputeDMap(Dij,dh_mask,n_dh,lmax,sampling,dh_mask_d0,dh_mask_d1,Dij_d0,Dij_d1) ! in PythonWrapper.f95
            fortranname pycomputedmap
            use shtools, only: ComputeDMap
            real*8 dimension(Dij_d0,Dij_d1),intent(out),depend(Dij_d0,Dij_d1) :: Dij
            integer dimension(dh_mask_d0,dh_mask_d1),intent(in) :: dh_mask
            integer, optional,intent(in),depend(dh_mask_d0) :: n_dh = dh_mask_d0
            integer, optional,intent(in):: sampling = 1
            integer, intent(in) :: lmax
            integer, optional,intent(in),check(shape(dh_mask,0)==dh_mask_d0),depend(dh_mask) :: dh_mask_d0=shape(dh_mask,0)
            integer, optional,intent(in),check(shape(dh_mask,1)==dh_mask_d1),depend(dh_mask) :: dh_mask_d1=shape(dh_mask,1)
            integer, optional,intent(in),depend(lmax) :: Dij_d0 = (lmax+1)*(lmax+1)
            integer, optional,intent(in),depend(lmax) :: Dij_d1 = (lmax+1)*(lmax+1)
        end subroutine ComputeDMap

        subroutine SHReturnTapersMap(tapers,eigenvalues,dh_mask,n_dh,lmax,sampling,Ntapers,dh_mask_d0,dh_mask_d1,tapers_d0,tapers_d1,eigenvalues_d0) ! in PythonWrapper.f95
            fortranname pyshreturntapersmap
            use shtools, only: SHReturnTapersMap
            real*8 dimension(tapers_d0,tapers_d1),intent(out),depend(tapers_d0,tapers_d1) :: tapers
            real*8 dimension(eigenvalues_d0),intent(out),depend(eigenvalues_d0) :: eigenvalues
            integer dimension(dh_mask_d0,dh_mask_d1),intent(in) :: dh_mask
            integer, optional,intent(in),depend(dh_mask_d0) :: n_dh = dh_mask_d0
            integer, optional,intent(in) :: sampling = 1
            integer intent(in) :: lmax
            integer, optional,intent(in),depend(lmax) :: Ntapers = (lmax+1)*(lmax+1)
            integer, optional,intent(in),check(shape(dh_mask,0)==dh_mask_d0),depend(dh_mask) :: dh_mask_d0=shape(dh_mask,0)
            integer, optional,intent(in),check(shape(dh_mask,1)==dh_mask_d1),depend(dh_mask) :: dh_mask_d1=shape(dh_mask,1)
            integer intent(in) :: tapers_d0 = (lmax+1)*(lmax+1)
            integer intent(in) :: tapers_d1 = Ntapers
            integer intent(in) :: eigenvalues_d0 = Ntapers
        end subroutine SHReturnTapersMap

        subroutine Curve2Mask(dhgrid,n,sampling,profile,nprofile,NP,profile_d0,profile_d1,dhgrid_d0,dhgrid_d1) ! in PythonWrapper.f95
            fortranname pycurve2mask
            use shtools, only: Curve2Mask
            integer dimension(dhgrid_d0,dhgrid_d1),intent(out),depend(dhgrid_d0,dhgrid_d1) :: dhgrid
            integer intent(in) :: n
            integer, optional,intent(in) :: sampling = 1
            real*8 dimension(profile_d0,profile_d1),intent(in) :: profile
            integer,optional,intent(in),depend(profile_d0) :: nprofile = profile_d0
            integer :: NP
            integer, optional,intent(in),check(shape(profile,0)==profile_d0),depend(profile) :: profile_d0=shape(profile,0)
            integer, optional,intent(in),check(shape(profile,1)==profile_d1),depend(profile) :: profile_d1=shape(profile,1)
            integer, optional,intent(in),depend(n) :: dhgrid_d0 = n
            integer, optional,intent(in),depend(n) :: dhgrid_d1 = n*sampling
        end subroutine Curve2Mask

        subroutine MakeEllipseCoord(coord,lat,lon,dec,A_theta,B_theta,cinterval,cnum,coord_d0,coord_d1) ! in PythonWrapper.f95
            fortranname pymakeellipsecoord
            use shtools, only: MakeEllipseCoord
            real*8 dimension(coord_d0,coord_d1),intent(out),depend(coord_d0,coord_d1) :: coord
            real*8 intent(in) :: lat
            real*8 intent(in) :: lon
            real*8 intent(in) :: dec
            real*8 intent(in) :: A_theta
            real*8 intent(in) :: B_theta
            real*8, optional,intent(in) :: cinterval
            integer, optional,intent(out) :: cnum
            integer intent(in) :: coord_d0
            integer intent(in) :: coord_d1
        end subroutine MakeEllipseCoord

        subroutine MakeGravGradGridDH(cilm,lmax,gm,r0,a,f,vxx,vyy,vzz,vxy,vxz,vyz,n,sampling,lmax_calc,vyz_d0,vyz_d1,vyy_d0,vyy_d1,cilm_d0,cilm_d1,cilm_d2,vzz_d0,vzz_d1,vxy_d0,vxy_d1,vxx_d0,vxx_d1,vxz_d0,vxz_d1) ! in PythonWrapper.f95
            fortranname pymakegravgradgriddh
            use shtools, only: MakeGravGradGridDH
            real*8 dimension(cilm_d0,cilm_d1,cilm_d2),intent(in) :: cilm
            integer intent(in) :: lmax
            real*8 intent(in) :: gm
            real*8 intent(in) :: r0
            real*8 intent(in) :: a
            real*8 intent(in) :: f
            real*8 dimension(vxx_d0,vxx_d1),intent(out),depend(vxx_d0,vxx_d1) :: vxx
            real*8 dimension(vyy_d0,vyy_d1),intent(out),depend(vyy_d0,vyy_d1) :: vyy
            real*8 dimension(vzz_d0,vzz_d1),intent(out),depend(vzz_d0,vzz_d1) :: vzz
            real*8 dimension(vxy_d0,vxy_d1),intent(out),depend(vxy_d0,vxy_d1) :: vxy
            real*8 dimension(vxz_d0,vxz_d1),intent(out),depend(vxz_d0,vxz_d1) :: vxz
            real*8 dimension(vyz_d0,vyz_d1),intent(out),depend(vyz_d0,vyz_d1) :: vyz
            integer intent(out) :: n
            integer, optional,intent(in) :: sampling
            integer, optional,intent(in) :: lmax_calc
            integer intent(in) :: vyz_d0
            integer intent(in) :: vyz_d1
            integer intent(in) :: vyy_d0
            integer intent(in) :: vyy_d1
            integer, optional,intent(in),check(shape(cilm,0)==cilm_d0),depend(cilm) :: cilm_d0=shape(cilm,0)
            integer, optional,intent(in),check(shape(cilm,1)==cilm_d1),depend(cilm) :: cilm_d1=shape(cilm,1)
            integer, optional,intent(in),check(shape(cilm,2)==cilm_d2),depend(cilm) :: cilm_d2=shape(cilm,2)
            integer intent(in) :: vzz_d0
            integer intent(in) :: vzz_d1
            integer intent(in) :: vxy_d0
            integer intent(in) :: vxy_d1
            integer intent(in) :: vxx_d0
            integer intent(in) :: vxx_d1
            integer intent(in) :: vxz_d0
            integer intent(in) :: vxz_d1
        end subroutine MakeGravGradGridDH
    end interface 
end python module _SHTOOLS

! This file was auto-generated with f2py (version:2).
! See http://cens.ioc.ee/projects/f2py2e/
